---
title: LeetCode-数据结构
date: 2023-06-06 00:22:04
permalink: /pages/fcb663/

---
![1667956969733](/assets/1667956969733.png)





## 数组

### 414 第三大的数

#### 方法一：有序集合

我们可以遍历数组，同时用一个有序集合来维护数组中前三大的数。具体做法是每遍历一个数，就将其插入有序集合，若有序集合的大小超过 3，就删除集合中的最小元素。这样可以保证有序集合的大小至多为 3，且遍历结束后，若有序集合的大小为 3，其最小值就是数组中第三大的数；若有序集合的大小不足 3，那么就返回有序集合中的最大值。

```cpp
#include <iostream>
using namespace std;
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <numeric>
#include <functional>
#include <set>

void printVector(vector<int>& v) {
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        cout << *it << " ";
    }
    cout << endl;
}

class Solution {
public:
    int thirdMax(vector<int>& nums) {
        set<int> s;
        for (int num : nums) {
            s.insert(num);
            //大于3时，就把左边第一个数擦除
            if (s.size() > 3) {
                s.erase(s.begin());
            }
        }
        return s.size() == 3 ? *s.begin() : *s.rbegin();
    }
};

int main()
{
    vector<int> ivec;
    int num;
    do
    {
        cin >> num;
        ivec.push_back(num);
    } while (getchar() != '\n');

    //printVector(ivec);

    Solution s;
    cout << s.thirdMax(ivec)<<endl;

    system("pause");
    return 0;
}
```



### 581 最短无序连续子数组

#### 方法一：找无序列表下标的最大、最小值

从左向右，保存该过程的最大值，与当前值得max进行对比，如果小于说明已经到达了无序列表中了，就记录当前值，一直到有序列表为止，此时后半部分的有序列表中的第一个值，也要比前面的大或等于前面的最大值，记录下的位置就不会改动了

```cpp
#include <iostream>
using namespace std;
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <numeric>
#include <functional>
#include <set>

void printVector(vector<int>& v) {
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        cout << *it << " ";
    }
    cout << endl;
}

class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        if (nums.size() <= 1) return 0;
        int len = nums.size(), low = 0, high = len - 1, maxNum = nums[0], minNum = nums[len - 1];
        for (int i = 1; i < len; i++) {
            maxNum = max(maxNum, nums[i]);
            minNum = min(minNum, nums[len - 1 - i]);
            //如果小于当前的最大值，说明到达了无序列表，记录当前值，一直到有序列表位置
            //后半部分的有序列表的第一个值，也要比前面大或等于前面的最大值
            if (nums[i] < maxNum) low = i;
            if (nums[len - 1 - i] > minNum) high = len - 1 - i;
        }
        return low > high ? low - high + 1 : 0;
    }
};

int main()
{
    vector<int> ivec;
    int num;
    do
    {
        cin >> num;
        ivec.push_back(num);
    } while (getchar() != '\n');

    printVector(ivec);

    Solution s;
    s.findUnsortedSubarray(ivec);
    cout << s.findUnsortedSubarray(ivec) << endl;;

    system("pause");
    return 0;
}
```

### 605 种花问题

#### 方法一：连续三个0

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int flag = 0;
        //左右两端各增加一个0，不用考虑边界条件，任意位置处只要连续出现三个0就可以栽上一颗花
        flowerbed.insert(flowerbed.begin(), 0);
        flowerbed.push_back(0);
        for (int i = 0; i < flowerbed.size(); ++i) {
            if (flowerbed[i] == 0) {
                if (i + 1 < flowerbed.size() && i + 2 < flowerbed.size()) {
                    if (flowerbed[i + 1] == 0 && flowerbed[i + 2] == 0) {
                        //i多加1，移动两个位置
                        i = i + 1;  //因为每连续三个0，中间的那个0才是用来种花的，
                        //比如连续5个0的情况
                        flag += 1;
                    }
                }
            }
        }
        return flag >= n;
    }
};
```

### 628 三个数的最大乘积

#### 方法一：排序

首先将数组排序。

如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。

如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。

综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。

```cpp
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        int product;
        int len = nums.size();
        sort(nums.begin(), nums.end());
        //如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，
        //也可能是两个最小负数（即绝对值最大）与最大正数的乘积。
        product = max(nums[0] * nums[1] * nums[len - 1], nums[len - 1] * nums[len - 2] * nums[len - 3]);
        return product;
    }
};
```



### 643 子数组的最大平均数

#### 方法一：滑动窗口

不这么做会超时
//滑动窗口的方式，减去当前子数组的第一个数，加上子数组的后一个数
  sum = sum - nums[i - k] + nums[i];

```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int len = nums.size();
        //先计算一次sum
        double sum = accumulate(nums.begin(), nums.begin() + k, 0);
        double maxAverage = sum / k;
        for (int i = k; i < len; ++i) {
            //然后滑动窗口的方式，减去当前子数组的第一个数，加上子数组的后一个数
            //不这么做会超时
            sum = sum - nums[i - k] + nums[i];
            double currentAverage = sum / k;
            maxAverage = max(currentAverage, maxAverage);
        }
        return maxAverage;
    }
};
```



### 448 找到所有数组中消失的数字

#### 方法1：

把出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置 即为没有出现过的数

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ans;
        for (auto num : nums) {
            int pos = abs(num) - 1;
            if (nums[pos] > 0) {
                nums[pos] = -nums[pos];
            }
        }
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] > 0) {
                ans.push_back(i + 1);
            }
        }
        return ans;
    }
};
```

### 59 螺旋矩阵 II

#### 方法1：模拟法，设定边界

![1673087711816](/assets/1673087711816.png)

![1673087748478](/assets/1673087748478.png)

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> mat(n, vector<int>(n, 0));
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int num = 1, tar = n * n;
        while (num <= tar) {
            for (int i = l; i <= r; i++) mat[t][i] = num++; // left to right.
            ++t;
            for (int i = t; i <= b; i++) mat[i][r] = num++; // top to bottom.
            --r;
            for (int i = r; i >= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for (int i = b; i >= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        }
        return mat;
    }
};
```



### 283 移动零

#### 方法1：一次遍历

参考快速排序的思想，用0作为中间点，把不等于0的放到中间点的左边，相当于把0放到右边

中间点就是 0 本身，所以实现起来比快速排序简单很多，我们使用两个指针 i 和 j，只要 nums[i]!=0，我们就交换 nums[i] 和 nums[j]

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        if (nums.size() == 0) return;
        int j = 0;
        for (int i = 0; i < nums.size(); i++) {
            // 不为0就交换
            if (nums[i] != 0) {
                int tmp = nums[i];
                nums[i] = nums[j];
                nums[j] = tmp;
                j++;
            }
        }
    }
};
```







## 字符串

### 12 罗马数字转整数

#### 方法一：模拟

通常情况下，罗马数字中小的数字在大的数字的右边。若输入的字符串满足该情况，那么可以将每个字符视作一个单独的值，累加每个字符对应的数值即可。

```cpp 
#include <iostream>
using namespace std;
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <numeric>
#include <functional>
#include <set>
#include <unordered_map>

class Solution {
public:
    int romanToInt(string s) {
        int ans = 0;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            int value = symbolValues[s[i]];
            if (value < symbolValues[s[i + 1]]) {
                ans -= value;
            }
            else {
                ans += value;
            }
        }

        return ans;
    }

    unordered_map<char, int> symbolValues = {
        {'I', 1},
        {'V', 5},
        {'X', 10},
        {'L', 50},
        {'C', 100},
        {'D', 500},
        {'M', 1000},
    };

};

int main()
{
    string s;
    cin >> s;
    cout << s << endl;

    Solution ss;
    cout << ss.romanToInt(s) << endl;

    system("pause");
    return 0;
}
```



### 344 反转字符串

```cpp
class Solution {
public:
	void reverseString(vector<char>& s) {
		int l, r;
		for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--) {
			int tmp = s[j];
			s[j] = s[i];
			s[i] = tmp;
		}
	}
};
```



### 541 反转字符串II

#### 方法1：reverse

让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。要找的也就是每2 * k 区间的起点，这样写，程序会高效很多。

```cpp
class Solution {
public:
	string reverseStr(string s, int k) {
		for (int i = 0; i < s.size(); i += 2*k) {
			// 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
			if (i + k <= s.size()) {
				reverse(s.begin() + i, s.begin() + i + k);
			}
			else {
                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
				reverse(s.begin() + i, s.end());
			}
		}
		return s;
	}
};
```

### 5 替换空格

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

```cpp
class Solution {
public:
	string replaceSpace(string s) {
		int count = 0;
		int sOldSize = s.size();
		for (int i = 0; i < s.size(); i++) {
			if (s[i] == ' ') {
				count++;
			}
		}
		// 扩充数组到每个空格替换成"%20"之后的大小
		s.resize(s.size() + 2 * count);
		int sNewSize = s.size();
        // 从后向前替换空格，也就是双指针法，过程如下：i指向新长度的末尾，j指向旧长度的末尾。
		for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
			if (s[j] != ' ') {
				s[i] = s[j];
			}
			else {
				s[i] = '0';
				s[i - 1] = '2';
				s[i - 2] = '%';
				i -= 2;
			}
		}
		return s;
	}
};
```

### 151 反转字符串中的单词

#### 方法1：

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

```cpp
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```



### 28 找出字符串中第一个匹配项的下标

#### 方法1：KMP

[(1 封私信 / 18 条消息) 如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)](https://www.zhihu.com/question/21923021/answer/281346746)

**KMP**

我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用[PMT数组](https://www.zhihu.com/search?q=PMT数组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A281346746})，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为[next数组](https://www.zhihu.com/search?q=next数组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A281346746})。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。

![img](/assets/v2-40b4885aace7b31499da9b90b7c46ed3_720w.png)

**获取next数组**

其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。

具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。

![img](/assets/v2-645f3ec49836d3c680869403e74f7934_720w.png)

![img](/assets/v2-06477b79eadce2d7d22b4410b0d49aba_720w.png)

![img](/assets/v2-8a1a205df5cad7ab2f07498484a54a89_720w.png)

![img](/assets/v2-f2b50c15e7744a7b358154610204cc62_720w.png)

![img](/assets/v2-bd42e34a9266717b63706087a81092ac_720w.png)

```cpp
class Solution {
public:
	void getNext(int* next, string s) {
		next[0] = -1;
		int i = 0, j = -1;
		while (i < s.size() - 1) {
			if (j == -1 || s[i] == s[j]) {
				j++;
				i++;
				next[i] = j;
				// cout << next[i] << endl;
			}
			else {
				j = next[j];
			}
		}
	}

	int strStr(string haystack, string needle) {
		int i = 0;
		int j = 0;
		//int next[8] = { -1,0,0,1,2,3,4,0 };
		int next[needle.size()];
		getNext(next, needle);
		/*
		while((i<haystack.size())&&(j<needle.size()))//会报错
		因为计算给定字符串的（unsigned int型）长度，就是这一点！！！
		它的返回值是一个 unsigned int 类型。
		如果是 while ((i < haystack.size()) && (j < needle.size()))
		即j< needle.size()在执行时，
		由于两边的类型不一样所以要转换， 无符号比有符度号的内有效值范围大，
		所以将j转换成无符号的数字再比较， 这一转就出问题了，
		有符号的-1转换成无符号成了0xffffffff，这是无符号的最大值，
		所以i< needle.size()始终为false，所以我写的函数只要当j<0，必定跳出循环。
		在此建议使用 needle.size()函数的值作为条件循环时，应先赋值给int类型，或者使用c++中的string。
		*/
		int length_1 = haystack.size();
		int length_2 = needle.size();
		while (i < length_1 && j < length_2) {
			if (j == -1 || haystack[i] == needle[j]) {
				i++;
				j++;
			}
			else {
				j = next[j];
			}
		}
		if (j == needle.size())
			return i - j;
		return -1;
	}
};
```

### 459 重复的子字符串

#### 方法1：移动匹配

当一个字符串s：abcabc，内部由重复的子串组成，那么这个字符串的结构一定是这样的：由前后相同的子串组成。

![图一](/assets/20220728104518.png)

那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s，所以判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。如图：

![图二](/assets/20220728104931.png)

暴力解法O(m*n)，库函数实现O(m+n)

```cpp
class Solution {
public:
	bool repeatedSubstringPattern(string s) {
		string t = s + s;
		t.erase(t.begin());
		t.erase(t.end() - 1); // 掐头去尾
		if (t.find(s) == -1) {
			return false;
		}
		else {
			return true;
		}
	}
};
```









## 链表

### 141 环形链表

#### 方法1：快慢指针

当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。

当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。

```cpp
根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：


class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        while(fast != nullptr) {
            fast = fast->next;
            if(fast != nullptr) {
                fast = fast->next;
            }
            if(fast == slow) {
                return true;
            }
            slow = slow->next;
        }
        return nullptr;
    }
};

```





### 21 合并两个有序链表

#### 方法一：迭代（带头结点的版本，leetcode上不对）

```cpp
#include <iostream>
using namespace std;

//Definition for singly-linked list.
struct ListNode {
	int val;
	ListNode* next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode* next) : val(x), next(next) {}
};

//Definition for singly-linked list
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
		ListNode* p1 = list1->next; //指向list1的首元结点
		ListNode* p2 = list2->next; //指向list2的首元结点  
		ListNode* list3 = list1;    
		ListNode* p3 = list3; //指向头结点
		while (p1 && p2) {
			if (p1->val <= p2->val) {
				p3->next = p1; //从首元结点开始，而不是从头结点开始
				p3 = p3->next;
				p1 = p1->next;
			}
			else {
				p3->next = p2;
				p3 = p3->next;
				p2 = p2->next;
			}
		}
		//while循环执行完毕后，较长的链表还有余留一段元素，这段元素的起止地址就是pa或pb
		p3->next = (p1 ? p1 : p2);
		return list3;
	}
};

//尾插法创建不定长的单向链表
void createListTail(ListNode* L) {
	ListNode* r = L;
	do {
		ListNode* p = new ListNode;
		cin >> p->val;  //循环创建p，输入结点数据
		p->next = nullptr;
		r->next = p;
		r = p;
	} while (getchar() != '\n');
}

//输出链表元素
void printList(ListNode* L) {
	ListNode* p = L->next;
	while (p) {
		cout << p->val<<" ";
		p = p->next;
	}
	cout << endl;
}

int main()
{	
	ListNode* list1 = new ListNode;
	createListTail(list1);
	printList(list1);
	ListNode* list2 = new ListNode;
	createListTail(list2);
	printList(list2);

	Solution s;
	ListNode* list3 = s.mergeTwoLists(list1, list2);
	printList(list3);

	
	delete list2;
	delete list1;
	system("pause");
	return 0;
}
```

#### 方法 一：迭代（不带头结点的版本，leetcode上是对的）

1. 创建一个空表list3
2. 一次从list1或list2中摘取元素值较小的结点插入到list3表的最后，直到其中一个表变空为止
3. 继续将list1或list2其中一个表的剩余结点插入到list3表的最后

leetcode上面的链表都是不带头结点

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
		ListNode* p1 = list1; //list1没有头结点
		ListNode* p2 = list2; //list2没有头结点
		ListNode* list3 = new ListNode;    
		ListNode* p3 = list3;  //list3有头结点
		while (p1 && p2) {
			if (p1->val <= p2->val) {
				p3->next = p1; 
				p3 = p3->next;
				p1 = p1->next;
			}
			else {
				p3->next = p2;
				p3 = p3->next;
				p2 = p2->next;
			}
		}
		//while循环执行完毕后，较长的链表还有余留一段元素，这段元素的起止地址就是pa或pb
		p3->next = (p1 ? p1 : p2);
		return list3->next; //返回list3->next，因为list3是带头结点，头结点中的val为0
	}
};
```

### 206 反转链表

#### 方法一：迭代（leetcode上不带头结点的版本）

- 定义两个指针：prev和curr
- 每次让curr的next指向prev，实现一次局部反转

```cpp
#include <iostream>
using namespace std;

/// <summary>
/// 不带头结点
/// </summary>

struct ListNode {
	int val;
	ListNode* next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode* next) : val(x), next(next) {}
};


class Solution {
public:
	ListNode* reverseList(ListNode* head) {
		ListNode* prev = nullptr;
		//首先curr指向首元结点
		ListNode* curr = head;
		while (curr) {
			//利用next暂时存储curr结点的下一结点
			ListNode* next = curr->next;
			//curr的next指针域指向上次循环存储的prev前一结点
			curr->next = prev;
			//prev指向当前结点
			prev = curr;
			//curr指向下一结点
			curr = next;
		}
		return prev;
	}
};


//尾插法创建不定长的单向链表
void createListTail(ListNode* L) {
	ListNode* r = L;
	cin >> r->val;
	do {
		ListNode* p = new ListNode;
		cin >> p->val;  //循环创建p，输入结点数据
		p->next = nullptr;
		r->next = p;
		r = p;
	} while (getchar() != '\n');
}

//输出链表元素
void printList(ListNode* L) {
	ListNode* p = L;
	while (p) {
		cout << p->val << " ";
		p = p->next;
	}
	cout << endl;
}

int main()
{
	ListNode* list1 = new ListNode;
	createListTail(list1);
	printList(list1);

	Solution s;
	printList(s.reverseList(list1));

	delete list1;

	system("pause");
	return 0;
}
```

首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

### 24 两两交换链表中的结点

#### 方法一：迭代

```cpp
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		//创建哑结点dummyHead，令dummyHead.next=head
		ListNode* dummyHead = new ListNode(0, head);
		//令temp表示当前到达的结点，初始化时temp=dummyHead
		ListNode* temp = dummyHead;
		ListNode* node1;
		ListNode* node2;
		//如果temp的后面没有结点或者只有一个结点，则结束交换
		while (temp->next && temp->next->next) { 
			//node1指向temp的下一结点，node2指向temp的下下个结点
			node1 = temp->next;
			node2 = temp->next->next;
			//两两交换
			//交换之前的节点关系是 temp -> node1 -> node2，
			//交换之后的节点关系要变成 temp -> node2 -> node1
			temp->next = node2;
			node1->next = node2->next;
			node2->next = node1;
			//令temp=node1
			temp = node1;
		}
		return dummyHead->next;
	}
};
```

#### 方法2：第2次写的迭代

![24.两两交换链表中的节点2](/assets/jksdhfa8212763sddlkfja.png)

![24.两两交换链表中的节点3](/assets/93452sdfkhjas7224.png)

```cpp
class Solution {
public:
	ListNode* swapPairs(ListNode* head) {
		ListNode* dummyHead = new ListNode(0);
		dummyHead->next = head;
		ListNode* cur = dummyHead;
		while (cur->next!=nullptr && cur->next->next!=nullptr) {
			ListNode* tmp1 = cur->next;
			ListNode* tmp2 = cur->next->next->next;

			cur->next = tmp1->next;
			cur->next->next = tmp1;
			tmp1->next = tmp2;
			
			
			cur = cur->next->next;
		}
		return dummyHead->next;
	}
};
```



### 160 相交链表

#### 方法一：相交的话必在相交的起始点相遇

如果不相交，则相遇处为NULL

```cpp
class Solution {
public:
	// 设A的长度为a+c，B的长度为b+c；其中c为A、B的公共部分；
	// 拼接AB、BA：A+B=a+c+b+c B+A=b+c+a+c；由于a+c+b=b+c+a，因此二者必定在c的起始点处相遇
	ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
		ListNode* curA = headA, * curB = headB;
		while (curA != curB) {
			// 每次判断当前点是否为空的好处是：避免A B无公共部分，
			// 再走完A+B和B+A后，会在nullptr处相遇
			curA = curA ? curA->next : headB;
			curB = curB ? curB->next : headA;
		}
		return curA;
	}
};
```

### 24 回文链表

#### 方法一：复制到数组后采用双指针法

```cpp
#include <iostream>
using namespace std;
#include <vector>

/// <summary>
/// 不带头结点
/// </summary>


//Definition for singly-linked list.
struct ListNode {
	int val;
	ListNode* next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode* next) : val(x), next(next) {}
};


class Solution {
public:
	bool isPalindrome(ListNode* head) {
		vector<int> elem;
		ListNode* p = head;
		//将链表赋值到数组
		while (p) {
			elem.push_back(p->val);
			p = p->next;
		}

		//双指针法
		int low = 0, high = elem.size() - 1;
		while (low <= high) {
			//一旦前后指针搜索到的数组元素不相同，就返回false
			if (elem[low] != elem[high]) {
				return false;
			}
			//相同的话前后指针就继续移动
			else {
				++low;
				--high;
			}
		}
		//都相等就返回true
		return true;
	}
};

//尾插法创建不定长的单向链表
ListNode* createListTail() {
	ListNode* L= new ListNode;
	ListNode* r = L;
	cin >> r->val;
	do {
		ListNode* p = new ListNode;
		cin >> p->val;  //循环创建p，输入结点数据
		p->next = nullptr;
		r->next = p;
		r = p;
	} while (getchar() != '\n');
	return L;
}

//输出链表元素
void printList(ListNode* L) {
	ListNode* p = L;
	while (p) {
		cout << p->val << " ";
		p = p->next;
	}
	cout << endl;
}

int main()
{
	ListNode* list = createListTail();
	printList(list);

	Solution ss;
	cout << boolalpha << ss.isPalindrome(list) << endl;


	system("pause");
	return 0;
}
```

### 203 移除链表元素

#### 方法1：设置虚拟头结点

设置一个虚拟头结点，链表的所有结点都可以按照统一的方式进行移除

```cpp
class Solution {
public:
	ListNode* removeElements(ListNode* head, int val) {
		ListNode* dummyHead = new ListNode(0);
		dummyHead->next = head;
		ListNode* cur = dummyHead;
		while (cur->next != NULL) {
			if (cur->next->val == val) {
				ListNode* tmp = cur->next;
				cur->next = cur->next->next;
				delete tmp;
			}
			else {
				cur = cur->next;
			}
		}
		head = dummyHead->next;
		delete dummyHead;
		return head;
	}
};
```

### 19 删除链表的倒数第n个结点

#### 方法1：快慢指针

如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

```cpp
class Solution {
public:
	ListNode* removeNthFromEnd(ListNode* head, int n) {
		ListNode* dummyHead = new ListNode(0);
		dummyHead->next = head;
		ListNode* slow = dummyHead;
		ListNode* fast = dummyHead;
		for (int i = 0; i < n; i++) {
			fast = fast->next;
		}
		while (fast->next!=NULL) {
			fast = fast->next;
			slow = slow->next;	
		}
		slow->next = slow->next->next;
		return dummyHead->next;
	}
};
```

### 面试题 02.07.链表相交

#### 方法1：双指针，提前移动到同一起点

简单来说，就是求两个链表交点节点的**指针**。 这里同学们要注意，交点不是数值相等，而是指针相等。

为了方便举例，假设节点元素数值相等，则节点指针相等。

看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点：

![面试题02.07.链表相交_1](/assets/23471289v2ahkejkfafas.png)

我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图：

![面试题02.07.链表相交_2](/assets/234kjlsduafggaj1234823huk.png)

此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

否则循环退出返回空指针。

```cpp
class Solution {
public:
	ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
		ListNode* curA = headA;
		ListNode* curB = headB;
		int lenA = getLength(headA);
		int lenB = getLength(headB);
		if (lenA > lenB) { //链表A更长，链表A往后移
			for (int i = 0; i < lenA - lenB; i++) {
				curA = curA->next;
			}
		}
		else if (lenA < lenB) { //链表B更长，链表B往后移到同一起点
			for (int i = 0; i < lenB - lenA; i++) {
				curB = curB->next;
			}
		}
		else { ; }

		for (int i = 0; i < lenB; i++) {
			if (curA == curB) return curA;
			curA = curA->next;
			curB = curB->next;
		}
		return nullptr;
	}

	int getLength(ListNode* head) {
		ListNode* p = head;
		int len = 0;
		while (p != NULL) {
			++len;
			p = p->next;
		}
		return len;
	}
};
```



### 876 链表的中间结点

#### 方法1：

==关键，两种情况的区别==

![876-1.png](/assets/2b7a4130111600cf615b5584b3cc7f863d289a9a7d43b90147c79f51f68a5aa6-876-1.png)

![876-2.png](/assets/5c3f88cc6b312b7193a6e071cef93ec5eb3070005af23cad22a11e10ea0aca3e-876-2.png)

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }

        ListNode* slow = head;
        ListNode* fast = head;

        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```



### 148 排序链表

#### 方法1：自定向下归并排序

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        return sortList(head, nullptr);
    }

    // 找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。
    ListNode* sortList(ListNode* head, ListNode* tail) {
        if (head == nullptr) return head;
        if (head->next == tail) {
            head->next = nullptr;
            return head;
        }
        ListNode* slow = head, * fast = head;
        while (fast != tail) {
            slow=slow->next;
            fast=fast->next;
            if (fast != tail) {
                fast = fast->next;
            }
        }
        ListNode* mid = slow;
        // 对两个子链表分别排序
        return merge(sortList(head, mid), sortList(mid, tail));
    }

    // 将两个排序后的子链表合并，得到完整的排序后的链表
    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummyHead = new ListNode(0);
        ListNode* temp = dummyHead, * temp1 = head1, * temp2 = head2;
        while (temp1 != nullptr && temp2 != nullptr) {
            if (temp1->val <= temp2->val) {
                temp->next = temp1;
                temp1 = temp1->next;
            }
            else {
                temp->next = temp2;
                temp2 = temp2->next;
            }
            temp = temp->next;
        }

        if (temp1 != nullptr) {
            temp->next = temp1;
        }
        else if (temp2 != nullptr) {
            temp->next = temp2;
        }
        return dummyHead->next;
    }
};
```



## 哈希表

### 242 有效字母的异位词

#### 方法1：数组哈希表

```cpp
class Solution {
public:
	bool isAnagram(string s, string t) {
		int record[26] = { 0 };
		for (int i = 0; i < s.size(); i++) {
			// s字符串中有就++
			record[s[i] - 'a']++;
		}
		for (int i = 0; i < t.size(); i++) {
			// t字符串中有就--
			record[t[i] - 'a']--;
		}
		for (int i = 0; i < 26; i++) {
			// 全为0就符合要求
			if (record[i] != 0) return false;
		}
		return true;
	}
};
```



### 128 最长连续序列

#### 方法1：哈希表

```cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> uset;
        for (auto num : nums) {
            uset.insert(num);
        }

        int longestStreak = 0;

        for(auto num:uset){
            if (!uset.count(num - 1)) {
                // 因为没有num-1那个数，所以num是当前连续序列的第一个数，此时才会进入内层循环
                int currentNum = num;
                int currentStreak = 1;

                // 如果有当前数的下一个数，就继续累加
                while (uset.count(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }
                longestStreak = max(currentStreak, longestStreak);
            }
        }
        return longestStreak;
    }
};
```



### 146 LRU缓存

#### 方法1：哈希表+双向链表

- 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

- 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。






### 2 两数之和

- 将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 `987 + 23 = 1010`
- 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值
- 如果两个链表全部遍历完毕后，进位值为 11，则在新链表最前方添加节点 1
- 小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。

```cpp
class Solution {
public:
	ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
		// 当返回结果为头结点时，先初始化一个预先指针pre，该指针的下一个节点
		// 指向真正的头结点
		ListNode* dummy = new ListNode();
		ListNode* pre = dummy;
		int carry = 0;
		while (l1 || l2 || carry) {
			if (l1) {
				carry += l1->val;
				l1 = l1->next;
			}
			if (l2) {
				carry += l2->val;
				l2 = l2->next;
			}
			ListNode* tmp = new ListNode(carry % 10);
			pre->next = tmp;
			pre = pre->next;
			carry /= 10;
		}
		return dummy->next;
	}
};
```



### 383 赎金信

#### 方法1：数组哈希表

用数组就行

```cpp
class Solution {
public:
	bool canConstruct(string ransomNote, string magazine) {
		int record[26] = { 0 };
		if (ransomNote.size() > magazine.size()) {
			return false;
		}
		for (int i = 0; i < magazine.size(); i++) {
			record[magazine[i] - 'a']++;
		}
		for (int i = 0; i < ransomNote.size(); i++) {
			record[ransomNote[i] - 'a']--;
			if (record[ransomNote[i] - 'a'] < 0) {
				return false;
			}
		}
		return true;
	}
};

```



### 349 两个数组的交集

#### 方法1：unordered_set哈希表

![set哈希法](/assets/20220707173513-1673168297701.png)

```cpp
class Solution {
public:
	vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
		unordered_set<int> result;
		unordered_set<int> tmp(nums1.begin(), nums1.end());
		for(int num:nums2){
			if (tmp.find(num) != tmp.end()) {
				result.insert(num);
			}
		}
		return vector<int>(result.begin(), result.end());
	}
};
```

### 202 快乐数

#### 方法1：unordered_set哈希表

哈希表来存储sum，如果重复出现了，说明陷入死循环；
如果==1，说明是快乐数。

```cpp
class Solution {
public:
	int getSum(int n) {
		int sum = 0;
		while (n) {
			sum += (n % 10) * (n % 10);
			n /= 10;
		}
		return sum;
	}

	bool isHappy(int n) {
		int sum;
		unordered_set<int> us;
		while (1) {
			sum = getSum(n);
			if (sum == 1) return true;
			if (us.find(sum) != us.end()) {
				return false;
			}
			else {
				us.insert(sum);
			}
			n = sum;
		}
	}
};
```

### 1 两数之和

#### 方法1：unordered_map哈希表

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
		unordered_map<int, int> us;
		for (int i = 0; i < nums.size(); ++i) {
			//查询哈希表中是否存在target-nums[i]
			auto it = us.find(target - nums[i]);
			//如果找到了，直接返回
			if (it != us.end()) {
				return { it->second,i };
			}
			//将nums[i]插入到哈希表中，可以保证不与自己匹配
			us[nums[i]] = i;
		}
		return {};
    }
};
```

### 454 四数相加 II

#### 方法1：unordered_map哈希表

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```cpp
class Solution {
public:
	int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
		unordered_map<int, int> um; //key:a+b的数值，value:a+b数值出现的次数
		int count = 0;
		// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到um中
		for (int a : nums1) {
			for (int b : nums2) {
				um[a + b]++;
			}
		}
		// 在遍历nums3和nums4数组，找到如果 0-(c+d) 在um中出现过的话，
		// 就把um中key对应的value也就是出现次数统计出来。
		for (int c : nums3) {
			for (int d : nums4) {
				auto it = um.find(0 - (c + d));
				if (it != um.end()) {
					count += um[0 - (c + d)];
				}
			}
		}
		return count;
	}
};
```



### 169 多数元素

#### 方法1：哈希表

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        unordered_map<int, int> umap;
        int result = 0;
        int maxNum = 0;
        for (auto num : nums) {
            umap[num]++;
            if(umap[num]>maxNum){
                maxNum = umap[num];
                result = num;
            }
        }
        return result;
    }
};
```



### 49 字母异位词

#### 方法1：哈希表

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> umap;
        for (auto str : strs) {
            auto key = str;
            sort(key.begin(), key.end());
            // 互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行
            // 排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希
            // 表的键。
            umap[key].emplace_back(str);
        }

        vector<vector<string>> ans;
        for (auto it = umap.begin(); it != umap.end(); it++) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```



### 12 整数转罗马数字

#### 方法1：贪心哈希表

每次都尽量使用最大的数来表示

```cpp
class Solution {
public:
    string intToRoman(int num) {
        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        string reps[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        string res;
        for (int i = 0; i < 13; i ++ )  //这里不使用图里的count了，一遍一遍来就行了
            while(num >= values[i])
            {
                num -= values[i];
                res += reps[i];
            }
        return res;
    }
};

```



## 栈与队列

### 155 最小栈

#### 方法一：双栈（stack容器）

用stack容器创建两个栈，一个栈用来存储实际元素，一个栈用来存储最小元素

```cpp
#include <iostream>
using namespace std;
#include <stack>
#include <algorithm>


class MinStack {
public:
    MinStack() {
        min_stack.push(INT_MAX); //min_stack先初始化一个无穷大的数
    }

    void push(int x) {
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x)); //min_stack的栈顶元素一直是最小的
    }

    void pop() {
        x_stack.pop();
        min_stack.pop();
    }

    int top() {
        return x_stack.top();
    }

    int getMin() {
        return min_stack.top();
    }

private:
    stack<int> x_stack;
    stack<int> min_stack;
};
/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

### 225 用队列实现栈

#### 方法一：两个队列（queue容器）

通过一个辅助queue容器q2，将后插入的元素排到队头，而不是队尾

```cpp
#include <iostream>
using namespace std;
#include <queue>


class MyStack {
public:
    MyStack() {

    }

    void push(int x) {
        //q2用于辅助
        //queue容器是队列，先进先出
        //通过这种方式将后入的元素排到队头
        q2.push(x);
        while (!q1.empty()) {
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1, q2);
    }

    int pop() {
        int r = q1.front();
        //pop是队头的元素
        q1.pop();
        return r;
    }

    int top() {
        int r = q1.front();
        return r;
    }

    bool empty() {
        return q1.empty();
    }
private:
    queue<int> q1;
    queue<int> q2;
};
```

### 232 用栈实现队列

#### 方法1：

```cpp
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;

    MyQueue() {

    }

    void push(int x) {
        stIn.push(x);
    }

    int pop() {
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    int peek() {
        int res = this->pop();
        stOut.push(res);
        return res;
    }

    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```



### 20 有效的括号

#### 方法1：栈

![20.有效括号](/assets/jyh8921nksdalkewjqiwer.gif)

- 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false
- 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false
- 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false
- 什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
}
```



### 1047 删除字符串中的所有相邻重复项

#### 方法1：栈

```cpp
// 把字符串直接当成栈
// 栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素,再做对应的消除操作
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for (int i = 0; i < s.size();i++) {
            if (result.empty() || result.back() != s[i]) {
                result.push_back(s[i]);
            }
            else {
                result.pop_back();
            }
        }
        return result;
    }
};
```

### 150 求逆波兰表达式求值

#### 方法1：栈

![150.逆波兰表达式求值](/assets/14234hxvbasdfhqw3421.gif)

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 力扣修改了后台测试数据，需要用longlong
        stack<long long> st; 
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
```



### 739 每日温度

#### 方法1：单调栈

**什么时候用单调栈：通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。

单调栈的本质是空间换时间，就是用一个栈来记录遍历过的元素。容器用单调栈

```
1.单调栈里存放的元素是什么？
单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

2.单调栈里元素是递增呢？ 还是递减呢？
这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，栈里要加入一个元素i的时候，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i。
即：如果求一个元素右边第一个更大元素，单调栈就是递增的，如果求一个元素右边第一个更小元素，单调栈就是递减的。

```

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        stack<int> st; // 递增栈
        vector<int> result(T.size(), 0);
        for (int i = 0; i < T.size(); i++) {
            while (!st.empty() && T[i] > T[st.top()]) { // 注意栈不能为空
                result[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);

        }
        return result;
    }
};
```



### 496 下一个更大元素I

#### 方法1：单调栈

定义一个和nums1一样大小的数组result来存放结果。

题目说如果不存在对应位置就输出 -1 ，所以result数组如果某位置没有被赋值，那么就应该是是-1，所以就初始化为-1。

**题目中说是两个没有重复元素 的数组 nums1 和 nums2**。没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下标元素，value：下标
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            while (!st.empty() && nums2[i] > nums2[st.top()]) {
                if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                    int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标
                    result[index] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
        return result;
    }
};
```



### 503 下一个更大元素II

#### 方法1：单调栈

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return result;
    }
};
```



### 394 字符串解码

#### 方法1：辅助栈法

要Debug才能知道具体的步骤

![1679111393777](/assets/1679111393777.png)

```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<pair<int, string>> sta;
        int num = 0;
        string res = "";
        // 循环检查字符串
        for (int i = 0; i < s.size(); i++) {
            // 遇到数字则存入num
            if (s[i] >= '0' && s[i] <= '9') {
                num *= 10;
                num += (s[i] - '0'); // 取出数字，十位数百位数都有可能
            }
            else if (s[i] == '[') {
                // 遇到'['，压栈数字和字符串，置零置空
                sta.push(make_pair(num, res));
                num = 0;
                res = "";
            } 
            else if (s[i] == ']') { // 遇到']'，出栈数字和字符串，然后进行组装
                int n = sta.top().first; //n指示的是res的循环次数，不是a的
                string a = sta.top().second;
                sta.pop();
                for (int i = 0; i < n; i++) a = a + res; //循环n次
                res = a;
            }
            else { // 遇到字符存入字符
                res += s[i];
            }
        }
        return res;
    }   
};
```



## 树

### 144 二叉树的前序遍历

#### 方法1：递归

```cpp
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr)  return;
        result.push_back(cur->val);
        traversal(cur->left,result);
        traversal(cur->right, result);

    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 方法2：迭代法

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

### 145 二叉树的后序遍历

#### 方法1：递归

```cpp
class Solution {
public:
    void helper(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr) return;
        helper(cur->left, result);
        helper(cur->right, result);
        result.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        helper(root, result);
        return result;
    }
};
```

#### 方法2：后序遍历

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```



### 94 二叉树的中序遍历

#### 方法1：递归

```cpp
class Solution {
public:
    void helper(TreeNode* cur, vector<int>& result) {
        if (cur == nullptr) return;
        helper(cur->left, result);
        result.push_back(cur->val);
        helper(cur->right, result);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>result;
        helper(root, result);
        return result;
    }
};
```

#### 方法2：迭代法

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```



### 102 二叉树的层序遍历

#### 方法1：队列

![102二叉树的层序遍历](/assets/kfw83421jkasfweaefwf.gif)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if (root == nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            // 每次size完，表示一层
            for (int i = 0; i < size; ++i) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};

```







### 104 求二叉树的最大深度

#### 方法一：递归调用

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <queue>

// Definition for a binary tree node.
 struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 };
 
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }
        int m = maxDepth(root->left);
        int n = maxDepth(root->right);
        if (m > n) {
            return m + 1;
        }
        else {
            return n + 1;
        }
    }
};



//根据数组，层次法创建二叉树
TreeNode* createTree(vector<int>& l_nums, int i) //层次法创建二叉树
{
    if (i >= l_nums.size() || l_nums[i] == 0) //数值为0或超出数组范围
        return nullptr;
    TreeNode* root = new TreeNode(l_nums[i]);
    root->left = createTree(l_nums, i * 2 + 1);
    root->right = createTree(l_nums, i * 2 + 2);
    return root;
}


int main()
{
    vector<int> nums = { 3,9,20,0,0,15,7 };
    TreeNode* root = createTree(nums, 0);
    
    Solution ss;
    cout << ss.maxDepth(root) << endl;

    system("pause");
    return 0;
}
```



### 111 二叉树的最小深度

#### 方法1：递归，后序遍历

![111.二叉树的最小深度](/assets/20210203155800503.png)

- 如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。
- 右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 
- 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

```cpp
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == nullptr) return 0;
        int leftDepth = getDepth(node->left); // 左
        int rightDepth = getDepth(node->right); // 右

        // 左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度
        if (node->left == nullptr && node->right != nullptr) {
            return 1 + rightDepth;
        }
        // 右子树为空，左子树不为空，最小深度是 1 + 左子树的深度
        if (node->left != nullptr && node->right == nullptr) {
            return 1 + leftDepth;
        }
        // 如果左右子树都不为空，返回左右子树深度最小值 + 1
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```



### 226 翻转二叉树

#### 方法1：前序遍历递归

```cpp
class Solution {
public:
    // 1.确定递归函数的参数和返回值
    // 返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为TreeNode*。
    TreeNode* invertTree(TreeNode* root) {
        // 2.确定终止条件
        // 当前节点为空的时候，就返回
        if (root == nullptr) return nullptr;
        // 3.确定单层递归的逻辑
        // 因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

### 222 完全二叉树的节点个数

#### 方法1：递归

```cpp
class Solution {
private:
    // 确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。
    int getNodesNum(TreeNode* cur) {
        // 确定终止条件：如果为空节点的话，就返回0，表示节点数为0。
        if (cur == NULL) return 0;
        // 确定单层递归的逻辑：先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。
        int leftNum = getNodesNum(cur->left);      // 左
        int rightNum = getNodesNum(cur->right);    // 右
        int treeNum = leftNum + rightNum + 1;      // 中
        return treeNum;
    }
public:
    int countNodes(TreeNode* root) {
        return getNodesNum(root);
    }
};
```



### 110 平衡二叉树

#### 方法一：自顶向下递归

```cpp
class Solution {
public:
	int height(TreeNode* root) {
		if (root == NULL) {
			return 0;
		}
		else {
			//获取当前子树的深度
			return max(height(root->left), height(root->right)) + 1;
		}
	}

	bool isBalanced(TreeNode* root) {
		if (root == NULL) {
			return true;
		}
		else {
			//左右子树的深度差皆满足条件
			return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
		}
	}
};
```

### 543 二叉树的直径

#### 方法一：递归

```cpp
class Solution {
public:
	int maxDepth = 0;
    int diameterOfBinaryTree(TreeNode* root) {
		depth(root);
		return maxDepth;
    }

	int depth(TreeNode* node) {
		if (!node) {
			return 0;
		}
		int left = depth(node->left);
		int right = depth(node->right);
		//将每个节点最大直径（左子树深度+右子树深度）与当前最大值比较并取较大者
		maxDepth = max(left + right, maxDepth);
		//返回节点深度
		return max(left, right) + 1;
	}
};
```

### 437 路径总和III

#### 方法一：深度优先搜索，递归

```C++
class Solution {
public:
	int pathSum(TreeNode* root, int targetSum) {
		if (root) {
			return pathSumStartWithRoot(root, targetSum) + 
				pathSum(root->left, targetSum) + pathSum(root->right, targetSum);
		}
		else {
			return 0;
		}
	}

	long long pathSumStartWithRoot(TreeNode* root, long long sum) {
		if (!root) {
			return 0;
		}

		long long count;
		if (root->val == sum) {
			count = 1;
		}
		else {
			count = 0;
		}

		count += pathSumStartWithRoot(root->left, sum - root->val);
		count += pathSumStartWithRoot(root->right, sum - root->val);
		return count;
	}
};
```

### 101 对称二叉树

#### 方法一：递归

比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要同时遍历两棵树。

```c++
#include <iostream>
using namespace std;
#include <vector>
#include <queue>

// Definition for a binary tree node.
struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};


class Solution {
public:
	bool isSymmetric(TreeNode* root) {
		if (root) {
			return isSymmetric(root->left, root->right);
		}
		else{
			return true;
		}
	}

	bool isSymmetric(TreeNode* left, TreeNode* right) {
		//如果两个子树都为空指针，则它们相等或对称
		if (!left && !right) {
			return true;
		}
		//如果两个子树只有一个为空指针，则它们不相等或不对称
		if (!left || !right) {
			return false;
		}
		//如果两个子树根结点的值不相等，则它们不相等或不对称
		if (left->val != right->val) {
			return false;
		}
		return isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);
	}
};


//根据数组，层次法创建二叉树
TreeNode* createTree(vector<int>& l_nums, int i) //层次法创建二叉树
{
	if (i >= l_nums.size() || l_nums[i] == 0) //数值为0或超出数组范围
		return nullptr;
	TreeNode* root = new TreeNode(l_nums[i]);
	root->left = createTree(l_nums, i * 2 + 1);
	root->right = createTree(l_nums, i * 2 + 2);
	return root;
}

//层次遍历，迭代法
void levelOrderIter(TreeNode* root) {
	queue<TreeNode*> que;
	que.push(root);
	while (!que.empty()) {
		cout << que.front()->val << " ";
		if (que.front()->left != nullptr) {
			que.push(que.front()->left);
		}
		if (que.front()->right != nullptr) {
			que.push(que.front()->right);
		}
		que.pop();
	}
	cout << endl;
}


int main()
{
	vector<int> nums = { 1,2,2,0,3,0,3 };
	TreeNode* root = createTree(nums, 0);
	levelOrderIter(root);

	Solution ss;
	cout << boolalpha << ss.isSymmetric(root) << endl;


	system("pause");
	return 0;
}
```

### 257 二叉树的所有路径

#### 方法1：递归

![257.二叉树的所有路径](/assets/20210204151702443.png)

```cpp
class Solution {
public:
    // 递归函数参数以及返回值,要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值
    void helper(TreeNode* cur, vector<int>& path, vector<string>& result) {
        // 因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。
        path.push_back(cur->val);
        // 当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。是本题的终止条件
        if (cur->left == nullptr && cur->right == nullptr) { // 遇到叶子节点
            string sPath;
            for (int i = 0; i < path.size()-1; ++i) { // 将path里记录的路径转为string格式
                sPath += to_string(path[i]);
                sPath += "->";
            }
            // 记录最后一个节点（叶子节点）
            // 放在for循环外面是因为不需要再加一个"->"
            sPath += to_string(path[path.size() - 1]); 
            result.push_back(sPath); // 收集一个路径
            return;
        }

        // 递归前要加上判断语句，判断下面要递归的节点是否为空
        // 递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。
        if (cur->left) { // 左
            helper(cur->left, path, result);
            path.pop_back(); // 回溯
        }

        if (cur->right) { // 右
            helper(cur->right, path, result);
            path.pop_back(); // 回溯
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if (root == nullptr) return result;
        helper(root, path, result);
        return result;
    }
};
```

### 404 左叶子之和

#### 方法1：递归

**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

```cpp
class Solution {
public:
    // 确定递归函数的参数和返回值，判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int
    int sumOfLeftLeaves(TreeNode* root) {
        // 确定终止条件
		// 如果遍历到空节点，那么左叶子值一定是0
        if (root == NULL) return 0;
        // 只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：
        if (root->left == NULL && root->right== NULL) return 0;

        // 确定单层递归的逻辑
		// 当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // 右

        int sum = leftValue + rightValue;               // 中
        return sum;
    }
};
```

### 513 找树左下角的值

#### 方法1：迭代法，层序遍历

使用层序遍历再合适不过了，只需要记录最后一行第一个节点的数值就可以了

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        int result = 0;
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;  
    }
};
```

### 112 路径总和

#### 方法1：递归

![112.路径总和](/assets/2021020316051216.png)

图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。



```cpp
class Solution {
private:
    // 确定递归函数的参数和返回类型
 	// 参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。
    // 本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？
    bool traversal(TreeNode* cur, int count) {
        
		// 确定终止条件
        // 计数器如何统计这一条路径的和呢？
		// 不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。
		// 如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。
		// 如果遍历到了叶子节点，count不为0，就是没找到。
        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
        if (!cur->left && !cur->right) return false; // 遇到叶子节点而没有找到合适的边，直接返回

        // 确定单层递归的逻辑
   		// 因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。
		// 递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。
        if (cur->left) { // 左 （空节点不遍历）
            count -= cur->left->val; // 递归，处理节点;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // 回溯，撤销处理结果
        }
        if (cur->right) { // 右 （空节点不遍历）
            count -= cur->right->val; // 递归，处理节点;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // 回溯，撤销处理结果
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```

### 1110 删点成林

#### 方法一：递归

![1669348588878](/assets/1669348588878.png)

构造一个helper辅助函数：对于一个root结点，如果是它是要被删除的结点，则向forest中添加其左右孩子，并将其置为null后返回，使其断开与其父结点之前的连接

```cpp
class Solution {
public:
	vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {
		vector<TreeNode*> forest;
		//容器元素都互不相等
		unordered_set<int> dict(to_delete.begin(), to_delete.end());
		root = helper(root, dict, forest);
		if (root) {
			//最后再将删除结点后的树放入forest中
			forest.push_back(root);
		}
		return forest;
	}

	TreeNode* helper(TreeNode* root, unordered_set<int>& dict, vector<TreeNode*>& forest) {
		if (!root) {
			return root;
		}
		root->left = helper(root->left, dict, forest);
		root->right = helper(root->right, dict, forest);
		if (dict.count(root->val)) {
			//被删除结点如果有左右子树就放入forest中
			if (root->left) {
				forest.push_back(root->left);
			}
			if (root->right) {
				forest.push_back(root->right);
			}
			//被删除的结点置为空
			root = NULL;
		}
		return root;
	}
};
```

### 637 二叉树的层平均值

#### 方法一：广度优先搜索，层次遍历法

```cpp
class Solution {
public:
	vector<double> averageOfLevels(TreeNode* root) {
		vector<double> ans;
		if (!root) {
			return ans;
		}
		queue<TreeNode*> q;
		q.push(root);
		while (!q.empty()) {
			//q的大小为上一次循环压入的某一层的结点总个数
			int count = q.size();
			double sum = 0;
			for (int i = 0; i < count; ++i) {
				TreeNode* node = q.front();
				q.pop();
				//q.size()次循环，获取到某一层结点值的总和
				sum += node->val;
				if (node->left) {
					q.push(node->left);
				}
				if (node->right) {
					q.push(node->right);
				}
			}
			ans.push_back(sum / count);
		}
		return ans;
	}
};
```

### 106 从中序与后序遍历序列构造二叉树

#### 方法1：递归

变量区间都采取左闭右开

```cpp
class Solution {
private:
    TreeNode* traversal (vector<int>& inorder, vector<int>& postorder) {
        // 1.如果数组大小为零的话，说明是空节点了。
        if (postorder.size() == 0) return NULL;

        // 2.如果不为空，那么取后序数组最后一个元素作为节点元素。
        int rootValue = postorder[postorder.size() - 1];
        TreeNode* root = new TreeNode(rootValue);

        // 叶子节点
        if (postorder.size() == 1) return root;

        // 3.找到后序数组最后一个元素在中序数组的位置，作为切割点
        int delimiterIndex;
        for (delimiterIndex = 0; delimiterIndex < inorder.size(); delimiterIndex++) {
            if (inorder[delimiterIndex] == rootValue) break;
        }

        // 4.切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
        // 左闭右开区间：[0, delimiterIndex)
        vector<int> leftInorder(inorder.begin(), inorder.begin() + delimiterIndex);
        // [delimiterIndex + 1, end)
        vector<int> rightInorder(inorder.begin() + delimiterIndex + 1, inorder.end() );

        // postorder 舍弃末尾元素
        postorder.resize(postorder.size() - 1);

        // 5.切割后序数组，切成后序左数组和后序右数组
        // 依然左闭右开，注意这里使用了左中序数组大小作为切割点
        // [0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        // 7.：递归处理左区间和右区间s
        root->left = traversal(leftInorder, leftPostorder);
        root->right = traversal(rightInorder, rightPostorder);

        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    }
};
```



### 654 最大二叉树

#### 方法1：递归

```cpp
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left >= right) return nullptr;

        // 找分割点，分割左右子树
        // 分割点下标：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i < right; ++i) {
            if (nums[i] > nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 构造左子树
        // 左闭右开：[left, maxValueIndex)
        root->left = traversal(nums, left, maxValueIndex);

        // 构造右子树
        // 左闭右开：[maxValueIndex + 1, right)
        root->right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```



### 617 合并二叉树

#### 方法1：递归

前序遍历

```cpp
class Solution {
public:
    // 要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
}
```



### 700 二叉搜索树中的搜索

#### 方法1：递归

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        // 如果root为空，或者找到这个数值了，就返回root节点。
        if (root == NULL || root->val == val) return root;
        TreeNode* result = NULL;
        // 如果root->val > val，搜索左子树，如果root->val < val，就搜索右子树，最后如果都没有搜索到，就返回NULL。
        if (root->val > val) result = searchBST(root->left, val);
        if (root->val < val) result = searchBST(root->right, val);
        return result;
    }
};
```



### 98 验证二叉搜索树

#### 方法1：递归

- 将二叉搜索树转变成一个数组，判断数组是否是有序的，二叉搜索树中不能有重复元素

```cpp
class Solution {
public:
    vector<int> vec;
    void helper(TreeNode* root) {
        if (root == nullptr) return;
        helper(root->left);
        vec.push_back(root->val);
        helper(root->right);
    }

    bool isValidBST(TreeNode* root) {
        vec.clear();
        helper(root);
        for (int i = 1; i < vec.size(); i++) {
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```



### 530 二叉搜索树的最小绝对差

#### 方法1：递归

需要用一个pre节点记录一下cur节点的前一个节点

![530.二叉搜索树的最小绝对差](/assets/20210204153247458.png)

```cpp
class Solution {
	private:
	int result = INT_MAX;
	TreeNode* pre = NULL;
	void traversal(TreeNode* cur) {
    	if (cur == NULL) return;
    	traversal(cur->left);   // 左
    	if (pre != NULL){       // 中
        	result = min(result, cur->val - pre->val);
    	}
    	pre = cur; // 记录前一个
    	traversal(cur->right);  // 右
	}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```



### 501 二叉搜索树中的众数

#### 方法1：二叉搜索树的中序遍历就是有序的

```cpp
class Solution {
private:
    int maxCount = 0; // 最大频率
    int count = 0; // 统计频率
    // 弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。
	// 而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};
```



### 236 二叉树的最近公共祖先

#### 方法1：递归，回溯，后序遍历

后序遍历（左中右）就是天然的回溯过程，可以根据左右子树的返回值，来处理中间节点的逻辑。如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。

本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。

递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？

搜索一条边的写法：

```cpp
// 递归函数返回值不为空的时候，立刻返回
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;
```

搜索整个树写法：

```cpp
// 如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

看出区别了没？

**在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）**。

![236.二叉树的最近公共祖先](/assets/2021020415105872.png)

不是直接返回7。

事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。

```cpp
left = 递归函数(root->left);  // 左
right = 递归函数(root->right); // 右
left与right的逻辑处理;         // 中 
```

为什么left为空，right不为空，目标节点通过right返回呢？

![236.二叉树的最近公共祖先1](/assets/20210204151125844.png)

图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！

![236.二叉树的最近公共祖先2](/assets/202102041512582.png)



```cpp
class Solution {
public:
    // 确定的返回值是最近公共节点，可以利用上题目中返回值是TreeNode * 
    // 如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // 如果 root == p，或者 root == 1，说明找到 p q ，则将其返回
        if (root == p || root == q || root == nullptr) return root;
        
        // 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点
        // 先用left和right接住左子树和右子树的返回值
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        // 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。
        // 如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解
		// 如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然。
        if (left != nullptr && right != nullptr) {
            // 如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。
            return root;
        }
        else if (left == nullptr && right != nullptr) {
            // left为空，right不为空，目标节点通过right返回
            return right;
        }
        else if (left != nullptr && right == nullptr) {
            // left不为空，right为空，目标节点通过left 返回
            return left;
        }
        else {
            // 如果left和right都为空，则返回left或者right都是可以的，也就是返回空
            return nullptr;
        }
    }
};
```



### 701 二叉搜索树中的插入操作

#### 方法1：递归

```cpp
class Solution {
public:
    // 有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 终止条件：就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回
        if (root == nullptr) {
            TreeNode* node = new TreeNode(val);
            // 把要添加的节点返回给上一层，完成父子节点的赋值操作
            return node;
        }
	
        // 通过递归函数返回值完成新加入节点的父子关系赋值操作了
        // 也就是下一层将加入节点返回，本层用root->left或者root->right将其接住。
        if (root->val > val) {
            root->left = insertIntoBST(root->left, val);
        }
        if (root->val < val) {
            root->right = insertIntoBST(root->right, val);
        }
        return root;
    }
};
```



### 108 将有序数组转换为二叉搜索树

#### 方法1：递归

```cpp
class Solution {
public:
    // 左闭右闭区间[left, right]，循环不变量，接下来一直坚持左闭右闭的区间
    TreeNode* helper(vector<int>& nums,int left, int right) {
        // 这里定义的是左闭右闭的区间，所以当区间 left > right的时候，就是空节点了
        if (left > right) return nullptr;
        // 这样可以防止left和right都是最大int时，导致的越界
        int mid = left + (right - left) / 2;

        // 取了中间位置，就开始以中间位置的元素构造节点
        TreeNode* root = new TreeNode(nums[mid
                                           
        // 划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点 
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right-1);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        // 传入的left和right是0和nums.size()-1，因为定义的区间为左闭右闭
        TreeNode* root = helper(nums, 0, nums.size()-1);
        return root;
    }
};

```



### 538 将二叉搜索树转换为累加树





### 450 删除二叉搜索树中的节点

#### 方法1：递归

```cpp
class Solution {
public:
    // 可以通过递归返回值来加入新节点，也可以通过递归返回值删除节点
    TreeNode* deleteNode(TreeNode* root, int key) {
        // 第一种情况：没找到删除的节点，遍历到空节点直接返回
        if (root == nullptr) return root;
        if (root->val == key) {
            
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                delete root;
                return retNode;
            }
            
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while (cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root; // 把root节点保存一下，下面来删除
                root = root->right;  // 返回旧root的右孩子作为新root
                delete tmp;  // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }

        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);

        return root;
    }
};
```



### 669 修剪二叉搜索树

#### 方法1：递归

![669.修剪二叉搜索树1](/assets/20210204155327203.png)



```cpp
// 如下代码相当于把节点0的右孩子（节点2）返回给上一层，
if (root->val < low) {
    TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
    return right;
}


// 然后如下代码相当于用节点3的左孩子 把下一层返回的 节点0的右孩子（节点2） 接住。
root->left = trimBST(root->left, low, high);

```

题解：

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        // 修剪的操作并不是在终止条件上进行的，所有遇到空节点返回就可以了
        if (root == nullptr) return nullptr;
        
        // 如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high);
            return right;
        }
       
        // 如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high);
            return left;
        }

        // 要将下一层处理完左子树的结果赋给root->left，处理完右子树的结果赋给root->right
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```



### 538 把二叉搜索树转换成累加树

#### 方法1：递归

**从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**

![538.把二叉搜索树转换为累加树](https://img-blog.csdnimg.cn/20210204153440666.png)

```cpp
class Solution {
public:
    // 定义一个全局变量pre，用来保存cur节点的前一个节点的数值
    int pre = 0;
    // 不需要递归函数的返回值做什么操作，要遍历整棵树
    void helper(TreeNode* cur) {
        // 遇空就终止
        if (cur == nullptr) return;
        helper(cur->right); // 右中左遍历
        cur->val += pre;
        pre = cur->val;
        helper(cur->left);
    }

    TreeNode* convertBST(TreeNode* root) {
        pre = 0;
        helper(root);
        return root;
    }
};
```



### 114 将二叉树展开为链表

#### 方法1：前序遍历

```cpp
class Solution {
public:
    void flatten(TreeNode* root) {
        vector<TreeNode*> help;
        preorderTraversal(root, help);
        // 展开为单链表后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序
        for (int i = 1; i < help.size(); i++) {
            TreeNode* pre = help[i - 1], *cur = help[i];
            pre->left = nullptr;
            pre->right = cur;
        }
    }

    // 前序遍历
    void preorderTraversal(TreeNode* root, vector<TreeNode*>& help) {
        if (root != nullptr) {
            help.push_back(root);
            preorderTraversal(root->left, help);
            preorderTraversal(root->right, help);
        }
    }
};
```



### 面试题04.02. 最小高度二叉树

#### 方法1：数组切割+递归

```cpp
class Solution {
public:
    /* 在左闭右开区间[left, right)，构造二叉树 */
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        /* 递归截止条件 */
        if (left >= right) return nullptr;
        /* 求取分割点下标：midValueIndex */
        int midValueIndex = left + (right-left)/2;// 赋值很巧妙可以更新 新数组的起点
        /* 更新节点值 */
        TreeNode* root = new TreeNode(nums[midValueIndex]);
        /* 左闭右开：[left, midValueIndex) */
        root->left = traversal(nums, left, midValueIndex);
        /* 左闭右开：[midValueIndex + 1, right)*/
        root->right = traversal(nums, midValueIndex + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size() == 0) return nullptr;
        return traversal(nums, 0, nums.size());
    }
};

```

