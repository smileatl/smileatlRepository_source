---
title: LeetCode-算法
date: 2023-06-06 08:51:54
permalink: /pages/00ac9f/

---
## 回溯算法

### 77 组合

#### 方法1：回溯

一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

- **每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。
- **图中可以发现n相当于树的宽度，k相当于树的深度**。
- **图中每次搜索到了叶子节点，我们就找到了一个结果**。
- 只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

int型变量startIndex，这个参数用来记录下一层递归，搜索的起始位置。

**终止条件**

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。此时用result二维数组，把path保存起来，并终止本层递归。

```cpp
class Solution {
public:
	vector<vector<int>> result; // 存放符合条件结果的集合
	vector<int> path; // 用来存放符合条件结果
	void backtracking(int n, int k, int startIndex) { // startIndex来记录下一层递归，搜索的起始位置。
        
        // path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。
        // 此时用result二维数组，把path保存起来，并终止本层递归。
		if (path.size() == k) {
			result.push_back(path);
			return;
		}
        
        // backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。
		for (int i = startIndex; i <= n; ++i) { // 控制树的横向遍历
			path.push_back(i); // 处理节点 
			backtracking(n, k, i + 1);  // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
			path.pop_back(); // 回溯，撤销处理的节点
		}
	}

	vector<vector<int>> combine(int n, int k) {
		result.clear(); // 可以不写
		path.clear();
		backtracking(n, k, 1);
		return result;
	}
};
```



### 216 组合总和III

#### 方法1：回溯

本题k相当于树的深度，9（因为整个集合就是9个数）就是树的宽度。

```cpp
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    // targetSum：目标和，也就是题目中的n。
    // k：题目中要求k个数的集合。
    // sum：已经收集的元素的总和，也就是path里元素的总和。
    // startIndex：下一层for循环搜索的起始位置。
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        
        // 如果path.size() 和 k相等了，就终止。
        // 如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。
        if (path.size() == k) {
            if (sum == targetSum) result.push_back(path);
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }
        for (int i = startIndex; i <= 9; i++) {
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(n, k, 0, 1);
        return result;
    }
};
```



### 17 电话号码的字母组合

#### 方法1：回溯

1. 数字和字母如何映射
2. 两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来
3. 输入1 * #按键等等异常情况

输入1 * #按键等等异常情况，代码中最好考虑这些异常情况，如果是现场面试，一定要考虑到

```cpp
// 版本一
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        // 确定终止条件
		// 例如输入用例"23"，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。
		// 那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。然后收集结果，结束本层递归。
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        
        // index指向的数字，并找到对应的字符集（手机键盘的字符集）
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```



### 30 组合的总和

#### 方法1：回溯

```cpp
// 版本一
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    // 一个集合里来求组合的话，就需要startIndex
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        
        // 从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。
        if (sum > target) {
            return;
        }
        if (sum == target) {
            // sum等于target的时候，需要收集结果
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < candidates.size(); i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i); // 不用i+1了，表示可以重复读取当前的数
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```



### 131 分割回文串

#### 方法1：回溯

```cpp
class Solution {
public:
	vector<vector<string>> result;
	vector<string> path;
	void backtracking(const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
		if (startIndex >= s.size()) {
			result.push_back(path);
			return;
		}
		for (int i = startIndex; i < s.size(); i++) {
            // 判断这个子串是不是回文，如果是回文，就加入在vector<string> path
			if (isPalindrome(s, startIndex, i)) {
                // 在for循环中，定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串
				string str = s.substr(startIndex, i - startIndex + 1);
				path.push_back(str);
			}
			else { // 如果不是则直接跳过
				continue;
			}

			backtracking(s, i + 1); // 寻找i+1为起始位置的子串，切割过的位置不能重复切割，传入下一层的起始位置为i+1
			path.pop_back(); // 回溯过程，弹出本次已经在的子串
		}

	}

	bool isPalindrome(const string& s, int start, int end) {
		for (int i = start, j = end; i < j; i++, j--) {
			if (s[i] != s[j]) {
				return false;
			}
		}
		return true;
	}

	vector<vector<string>> partition(string s) {
		backtracking(s, 0);
		return result;
	}
};
```



### 93 复原IP地址

#### 方法1：回溯(需要再认真做)

```cpp
class Solution {
private:
    vector<string> result;// 记录结果
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，说明字符串分成了4段，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
                // 如果合法就在字符串后面加上符号.表示已经分割
                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2，同时记录分割符的数量pointNum要+1
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            } else break; // 不合法，直接结束本层循环
        }
    }
    
    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    // 段位以0为开头的数字不合法
 	// 段位里有非正整数字符不合法
	// 段位如果大于255了不合法
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        if (s[start] == '0' && start != end) { // 0开头的数字不合法
                return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};
```



### 40 组合总和II

#### 方法1：回溯

```cpp
class Solution {
public:

	vector<vector<int>> result;
	vector<int> path;
	void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
		if (sum == target) {
			result.push_back(path);
			return;
		}
		
        // sum + candidates[i]<=target为剪枝操作
		for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target;i++) {
            // 要对同一树层使用过的元素进行跳过
            // 如果candidates[i] == candidates[i - 1]，并且i在startIndex后面，说明当前的取的candidates[i]是从candidates[i-1]回溯而来的，说明前一个树枝使用了candidates[i-1]，也就是说同一树层使用过candidates[i-1]
            // 此时for循环里就应该做continue操作
			if (i > startIndex && candidates[i] == candidates[i - 1]) {
				continue;
			}

			sum += candidates[i];
			path.push_back(candidates[i]);
            // 每个数字在每个组合中只能使用一次，所以是i+1
			backtracking(candidates, target, sum, i + 1);
			path.pop_back();
			sum -= candidates[i];
		}
	}


	vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
		path.clear();
		result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起
		sort(candidates.begin(), candidates.end());
		backtracking(candidates, target, 0, 0);
		return result;
	}
};
```



### 78 子集

#### 方法1：回溯

**是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**

![78.子集](/assets/202011232041348.png)

```cpp
class Solution {
public:
	vector<vector<int>> result;
	vector<int> path;
	void backtracking(vector<int>& nums, int startIndex) {
		result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        // startIndex已经大于数组的长度了，就终止了，因为没有元素可取了
		if (startIndex >= nums.size()) {
			return;
		}
		for (int i = startIndex; i < nums.size(); i++) {
			path.push_back(nums[i]);    // 子集收集元素
    		backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取
    		path.pop_back();            // 回溯
		}
	}


	vector<vector<int>> subsets(vector<int>& nums) {
		backtracking(nums, 0);
		return result;
	}
};
```



### 90 子集II

#### 方法1：回溯

主要是去重，**理解“树层去重”和“树枝去重”**

```cpp
class Solution {
public:
	vector<vector<int>> result;
	vector<int> path;
	void backtracking(vector<int>& nums, int startIndex) {
		result.push_back(path);
		for (int i = startIndex; i < nums.size(); i++) {
            // 我们要对同一树层使用过的元素进行跳过
            // 递归的时候下一个startIndex是i+1而不是0
            // 如果nums[i] == candidates[i - 1]，并且i在startIndex后面，说明当前的取的nums[i]是从nums[i-1]回溯而来的，说明前一个树枝使用了nums[i-1]，也就是说同一树层使用过nums[i-1]
			if (i > startIndex && nums[i] == nums[i - 1]) {
				continue;
			}

			path.push_back(nums[i]);
			backtracking(nums, i + 1);
			path.pop_back();
		}
		
	}


	vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        // 需要排序
		sort(nums.begin(), nums.end());
		backtracking(nums, 0);
		return result;
	}
};

```



### 491 递增子序列

#### 方法1：回溯

本题求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。**所以不能使用之前的去重逻辑！**

![491. 递增子序列1](/assets/20201124200229824.png)

```cpp
class Solution {
public:
	vector<vector<int>> result;
	vector<int> path;
	void backtracking(vector<int>& nums, int startIndex) {
		if (path.size() > 1) {
			result.push_back(path);
            // 注意这里不要加return，因为要取树上的所有节点
		}

		int used[201] = { 0 }; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100
		for (int i = startIndex; i < nums.size(); i++) {
			if ((!path.empty() && nums[i] < path.back()) || used[nums[i] + 100] == 1) {
				continue;
			}

			used[nums[i] + 100] = 1; // 记录这个元素在本层用过了，本层后面不能再用了。新的一层used都会重新定义（清空），所以知道used只负责本层
			path.push_back(nums[i]);
			backtracking(nums, i + 1);
			path.pop_back();
		}
	}


	vector<vector<int>> findSubsequences(vector<int>& nums) {
		backtracking(nums, 0);
		return result;
	}
};
```



### 46 全排列

#### 方法1：回溯



```cpp
class Solution {
public:
	vector<vector<int>> result;
	vector<int> path;
    // 排列是有序的，要重复用，所以处理排列问题就不用使用startIndex
	void backtracking(vector<int>& nums, vector<bool>& used) {
        // 可以看出叶子节点，就是收割结果的地方。
        // 收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。
		if (path.size() == nums.size()) {
			result.push_back(path);
			return;
		}
		
		for (int i = 0; i < nums.size(); ++i) {
			if (used[i] == true) continue;  // path里已经收录的元素，直接跳过
			used[i] = true;
			path.push_back(nums[i]);
			backtracking(nums, used);
			path.pop_back();
			used[i] = false;
		}
	}


	vector<vector<int>> permute(vector<int>& nums) {
        // used标记已经选择的元素
		vector<bool> used(nums.size(), false);
		backtracking(nums, used);
		return result;
	}
};
```



### 47 全排列II

#### 方法1：回溯

![47.全排列II1](/assets/20201124201331223.png)

```cpp
class Solution {
public:
	vector<vector<int>> result;
	vector<int> path;
	void backtracking(vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
		if (path.size() == nums.size()) {
			result.push_back(path);
			return;
		}

		for (int i = 0; i < nums.size(); i++) {
            // i目前为1，nums[i]==nums[i-1],而used[i-1]为false，说明同一树层上有两个重复的元素nums[i]和nums[i-1]，不可以重复选取
            
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过 
            // 如果同一树层nums[i - 1]使用过则直接跳过
			if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
				continue;
			}

			if (used[i] == false) {
				used[i] = true;
				path.push_back(nums[i]);
				backtracking(nums, used);
				path.pop_back();
				used[i] = false;
			}
		}
	}
    vector<vector<int>> permuteUnique(vector<int>& nums) {
		result.clear();
		path.clear();
		sort(nums.begin(), nums.end());
		vector<bool> used(nums.size(), false);
		backtracking(nums, used);
		return result;
    }
};

```



### 332 重新安排行程

#### 方法1：回溯

![332.重新安排行程1](/assets/2020111518065555.png)

在选择映射函数的时候，不能选择`unordered_map<string, multiset<string>> targets`， 因为一旦有元素增删multiset的迭代器就会失效

**本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效**。选择了`unordered_map<string, map<string, int>> targets` 来做机场之间的映射。

```cpp
class Solution {
public:
    // unordered_map<出发机场, map<到达机场, 航班次数>> targets
	unordered_map<string, map<string, int>> targets;
    // 返回bool，只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线
	bool backtracking(int ticketNum, vector<string> & result) {
        // 遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了
		if (result.size() == ticketNum + 1) { // 记录到达机场是否飞过了
			return true;
		}

        // result记录的最后一个数，作为本次的出发机场
		for (pair<const string, int> &target : targets[result[result.size() - 1]]) {
            // 对应本次出发机场的到达机场，其航班次数大于0时
			if (target.second > 0) { 
				target.second--;
                // 存入其达到机场
				result.push_back(target.first);
				if (backtracking(ticketNum, result)) return true;
				result.pop_back();
				target.second++;
			}
		}

		return false;
	}

	vector<string> findItinerary(vector<vector<string>>& tickets) {
		vector<string> result;
        // 把tickets映射为targets
		for (const vector<string> &vec : tickets) {
			targets[vec[0]][vec[1]]++; // 记录映射关系
		}
		result.push_back("JFK"); // 起始机场
		backtracking(tickets.size(), result);
		return result;
	}
};
```



### 51 N皇后

#### 方法1：回溯

![51.N皇后](/assets/20210130182532303.jpg)

二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

```cpp
class Solution {
public:
	vector<vector<string>> result;
    // n 为输入的棋盘大小
	// row 是当前递归到棋盘的第几行了
    // 参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了
	void backtracking(int n, int row, vector<string>& chessboard) {
        // 参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了
		if (row == n) {
			result.push_back(chessboard);
			return;
		}
        
        // 递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。
        // 每次都是要从新的一行的起始位置开始搜，所以都是从0开始。
		for (int col = 0; col < n; col++) { 
			if (isValid(row, col, chessboard, n)) { // 验证合法就可以放
				chessboard[row][col] = 'Q'; // 放置皇后
				backtracking(n, row + 1, chessboard);
				chessboard[row][col] = '.'; // 回溯，撤销皇后
			}
		}

	}

	bool isValid(int row, int col, vector<string>& chessboard, int n) {
        // 检查列
		for (int i = 0; i < row; i++) { // 这是一个剪枝，只验证到当前行为止
			if (chessboard[i][col] == 'Q') {
				return false;
			}
		}
		// 检查 45度角是否有皇后
		for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
			if (chessboard[i][j] == 'Q') {
				return false;
			}
		}
		// 检查 135度角是否有皇后
		for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
			if (chessboard[i][j] == 'Q') {
				return false;
			}
		}
		return true;
	}

	vector<vector<string>> solveNQueens(int n) {
		result.clear();
		std::vector<std::string> chessboard(n, std::string(n, '.'));
		backtracking(n, 0, chessboard);
		return result;
	}
};
```







### 37 解数独

#### 方法1：回溯

```cpp
class Solution {
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] == '.') {
                for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;                // 放置k
                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                        board[i][j] = '.';              // 回溯，撤销k
                    }
                }
                return false;  // 9个数都试完了，都不行，那么就返回false 
            }                
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3; // 会从九宫格最开始的那个数开始
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```



### 79 单词搜索

#### 方法1：回溯

```cpp
class Solution {
public:
    // 四个方向
    int dir[4][4] = { {-1,0},{1,0},{0,-1},{0,1} };

    bool exist(vector<vector<char>>& board, string word) {
        int m = board.size();
        int n = board[0].size();
        vector<vector<bool>> visited(m, vector<bool>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(i, j, 0, board, word, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(int x, int y, int index, vector<vector<char>>& board, string word, vector<vector<bool>>& visited) {
        // 终止条件：遍历到word的最后一个，返回最后一个是否相等
        if (index == word.size() - 1) {
            return word[index] == board[x][y];
        }

        // 如果相等，去处理节点
        if (word[index] == board[x][y]) {
            // 处理当前节点置为true
            visited[x][y] = true;
            for (int i = 0; i < 4; i++) {
                int new_x = x + dir[i][0];
                int new_y = y + dir[i][1];
                // 满足条件去进行递归
                if (new_x >= 0 && new_x < board.size() && new_y >= 0 && new_y < board[0].size() && !visited[new_x][new_y]) {
                    if (dfs(new_x, new_y, index + 1, board, word, visited)) {
                        return true;
                    }
                }
            }
            // 如果这个点的下一个点不行，重新把当前节点置为false
            // 也就是回溯撤销结果
            visited[x][y] = false;
        }
        return false;         
    }
};

```



## 贪心算法

### 445 分发饼干

#### 方法一：贪心

- 因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。
- 为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。
- 满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。

总结：给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>

vector<int> createVector() {
	vector<int> ivec;
	int num;
	do
	{
		cin >> num;
		ivec.push_back(num);
	} while (getchar() != '\n');
	return ivec;
}

void printVector(vector<int>& v) {
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

class Solution {
public:
	int findContentChildren(vector<int>& g, vector<int>& s) {
		sort(g.begin(), g.end()); //排序方便之后的大小比较
		sort(s.begin(), s.end());
		int count = 0;
		int child = 0, cookie = 0;
		while (child < g.size() && cookie < s.size()) {
			if (g[child] <= s[cookie]) {
				++child;
				++count;
			}
			++cookie;
		}
		return count;
	}
};


int main()
{
	vector<int> g, s;
	g = createVector();
	s = createVector();

	Solution ss;
	cout << ss.findContentChildren(g, s) << endl;;

	system("pause");
	return 0;
}
```

### 135  分发糖果

#### 方法一：贪心策略

- 把所有孩子的糖果数初始化为1；
- 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；
- 再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。

```cpp
//第一次自己按照思路写出来
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>
#include <numeric>

vector<int> createVector() {
	vector<int> ivec;
	int num;
	do
	{
		cin >> num;
		ivec.push_back(num);
	} while (getchar() != '\n');
	return ivec;
}

void printVector(vector<int>& v) {
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

class Solution {
public:
	int candy(vector<int>& ratings) {
		vector<int> candyNum;
		int len = ratings.size(); //获取孩子总数
		//将所有孩子的糖果数初始化为1
		for (int i = 0; i < len; ++i) {
			candyNum.push_back(1); 
		}
		//先从左往右遍历一遍，如果右边孩子的评分比左边的高，
		//则右边孩子的糖果数更新为左边孩子的糖果数加 1；
		for (int i = 1; i < len; ++i) {
			if (ratings[i] > ratings[i - 1]) {
				candyNum[i] = candyNum[i - 1] + 1;
			}
		}
		//再从右往左遍历一遍，如果左边孩子的评分比右边的高，
		//且左边孩子当前的糖果数不大于右边孩子的糖果数，
		//则左边孩子的糖果数更新为右边孩子的糖果数加 1。
		for (int i = len - 1; i >= 1; --i) {
			if (ratings[i - 1] > ratings[i] && candyNum[i-1]<=candyNum[i]) {
				candyNum[i - 1] = candyNum[i] + 1;
			}
		}
		//计算candyNum容器内糖果的总数，accumulate函数在<numeric>中
		int total = accumulate(candyNum.begin(), candyNum.end(), 0);
		return total;
	}
};

int main()
{
	vector<int> ratings;
	ratings = createVector();

	Solution ss;
	cout << ss.candy(ratings) << endl;

	system("pause");
	return 0;
}
```

leetcode101-高畅

```cpp
int candy(vector<int>& ratings) {
	int size = ratings.size();
	if (size < 2) {
		return size;
	}
	vector<int> num(size, 1); //vector容器构造函数，将size个1拷贝给本身
	for (int i = 1; i < size; ++i) {
		if (ratings[i] > ratings[i - 1]) {
			num[i] = num[i - 1] + 1;
		}
	}
	for (int i = size - 1; i > 0; --i) {
		if (ratings[i] < ratings[i - 1]) {
			num[i - 1] = max(num[i - 1], num[i] + 1);
		}
	}
	// std::accumulate可以很方便地求和
	return accumulate(num.begin(), num.end(), 0);
}
```



### 860 柠檬水找零

#### 方法1：贪心算法

```cpp
class Solution {
public:
	bool lemonadeChange(vector<int>& bills) {
		int five = 0, ten = 0, twenty = 0;
		for (int bill : bills) {
            // 1.账单是5，直接收下。
			if (bill == 5) {
				five++;
			}
            // 2.账单是10，消耗一个5，增加一个10
			if (bill == 10) {
				if (five <= 0) return false;
				five--;
				ten++;
			}
			if (bill == 20) {
                // 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着
				if (five > 0 && ten > 0) {
					five--;
					ten--;
					twenty++;
				}
				else if (five >= 3) {
					five -= 3;
					twenty++;
				}
				else {
					return false;
				}
			}
		}
		return true;
	}
};

```



### 406 根据身高重建队列

#### 方法1：贪心算法

两个维度的话先确定一个维度，再确定另一个维度

![406.根据身高重建队列](/assets/20201216201851982.png)

按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。

所以在按照身高从大到小排序后：

- **局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**
- **全局最优：最后都做完插入操作，整个队列满足题目队列属性**

```cpp
class Solution {
public:
    // 身高从大到小排，后一位从小到大排
	static bool cmp(const vector<int>& a, const vector<int>& b) {
		if (a[0] == b[0]) return a[1] < b[1];
		else return a[0] > b[0];
	}

	vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
		sort(people.begin(), people.end(), cmp);
		vector<vector<int>> que;
		for (int i = 0; i < people.size(); i++) {
			int position = people[i][1];
			que.insert(que.begin() + position, people[i]);
		}
		return que;
	}
};

```



### 452 用最少数量的箭引爆气球

#### 方法1：贪心算法

![452.用最少数量的箭引爆气球](/assets/20201123101929791.png)

**为了让气球尽可能的重叠，需要对数组进行排序**。**如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭**。

```cpp
class Solution {
private:
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        return a[0] < b[0];
    }
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);

        int result = 1; // points 不为空至少需要一支箭
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > points[i - 1][1]) {  // 气球i和气球i-1不挨着，注意这里不是>=
                result++; // 需要一支箭
            }
            else {  // 气球i和气球i-1挨着
                points[i][1] = min(points[i - 1][1], points[i][1]); // 更新重叠气球最小右边界
            }
        }
        return result;
    }
};
```



### 435 无重叠区间

#### 方法1：贪心算法

![img](/assets/20230201164134.png)

```cpp
class Solution {
public:
    // 按照右边界从小到大排序
	static bool cmp(const vector<int>& a, const vector<int>& b) {
		return a[1] < b[1];
	}

	int eraseOverlapIntervals(vector<vector<int>>& intervals) {
		if (intervals.size() == 0) return 0;
		sort(intervals.begin(), intervals.end(), cmp);
		int count = 1; // 记录非重叠区间的个数
		int end = intervals[0][1]; // 记录区间分割点
		for (int i = 1; i < intervals.size(); i++) {
			if (end <= intervals[i][0]) {
				end = intervals[i][1];
				count++;
			}
		}
		return intervals.size() - count; // 相减得到需要移除的重叠区间个数
	}
};
```

#### 方法一：贪心策略

​		求最少的移除区间个数，等价于尽量多保留不重叠的区间。在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。
因此，我们采取的贪心策略为，**优先保留结尾小且不相交的区间**。

- 先把区间按照结尾的大小进行增序排序
- 每次选择结尾最小且和前一个选择的区间不重叠的区间

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>
#include <numeric>

//vector容器嵌套容器的打印
void printVectorInVector(vector<vector<int>>& v) {
	//通过大容器，把所有数据遍历一遍
	for (vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++) {
		//(*it) ---- 容器 vector<int>
		for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
			cout << *vit << " ";
		}
		cout << endl;
	}
	//每一个小容器输出，输出完了做一个换行的操作
}

//按照谓词（函数对象，仿函数）的方式传入sort进行自定义排序
class myCompare {
public:
	//先把区间按照结尾的大小进行增序排序
	bool operator()(vector<int>& a, vector<int>& b) {
		return a[1] < b[1]; //[1]取出区间的结尾
	}
};

class Solution {
public:
	int eraseOverlapIntervals(vector<vector<int>>& intervals) {
		if (intervals.empty()) {
			return 0;
		}
		int n = intervals.size();
		//sort传入谓词myCompare()，把区间按照结尾的大小进行增序排序
		sort(intervals.begin(), intervals.end(), myCompare());
		//prev初始化为第0个区间的结尾
		int removed = 0, prev = intervals[0][1];
		for (int i = 1; i < n; ++i) {
			//如果下一个区间的开头大于上一个区间的结尾，说明有重叠，++removed
			if (intervals[i][0] < prev) {
				++removed;
			}
			else {
				prev = intervals[i][1];
			}
		}
		return removed;
	}
};

int main()
{
	vector<vector<int>> intervals = { {1, 2},{2, 3},{3, 4},{1, 3} };
	printVectorInVector(intervals);

	Solution ss;
	cout << ss.eraseOverlapIntervals(intervals) << endl;

	system("pause");
	return 0;
}


```



leetcode101-高畅

```cpp
class Solution {
public:
	int eraseOverlapIntervals(vector<vector<int>>& intervals) {
		if (intervals.empty()) {
			return 0;
		}
		int n = intervals.size();
		sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b)
			{	//使用C++的lambda，结合std::sort()函数进行自定义排序
				return a[1] < b[1];
			});
		int removed = 0, prev = intervals[0][1];
		for (int i = 1; i < n; ++i) {
			if (intervals[i][0] < prev) {
				++removed;
			}
			else {
				prev = intervals[i][1];
			}
		}
		return removed;
	}
};
```



代码随想录

```cpp
// 时间复杂度：O(nlogn)
// 空间复杂度：O(1)
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size() - 1; // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口 
            if (index >= 0 && s[index] >= g[i]) { // 遍历饼干 
                result++;
                index--;
            }
        }
        return result;
    }
};
```



### 376 摆动序列

#### 方法1：贪心算法

```cpp
class Solution {
public:
	int wiggleMaxLength(vector<int>& nums) {
		if (nums.size() <= 1) return nums.size();
		int curDiff = 0;
		int preDiff = 0;
		int result=1;
		for (int i = 0; i < nums.size() - 1; i++) {
			curDiff = nums[i + 1] - nums[i];
			if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
				result++;
				preDiff = curDiff;
			}
		}
		return result;
	}
};
```



### 53 最大子数组和

#### 方法1：贪心算法

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
};
```



### 121 买卖股票的最佳时机

#### 方法1：贪心

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            for (int j = i + 1; j < prices.size(); j++){
                result = max(result, prices[j] - prices[i]);
            }
        }
        return result;
    }
};
```



### 122 买卖股票的最佳时机

#### 方法1：贪心算法

![122.买卖股票的最佳时机II](/assets/2020112917480858.png)

从图中可以发现，其实我们需要收集每天的正利润就可以，**收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间**。

**局部最优：收集每天的正利润，全局最优：求得最大利润**。

```cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		int result = 0;
		for (int i = 1; i < prices.size(); i++) {
			if (prices[i] - prices[i - 1]>0) {
				result += prices[i] - prices[i - 1];
			}
		}
		return result;
	}
};
```

### 55 跳跃游戏

#### 方法1：贪心算法

**跳跃覆盖范围究竟可不可以覆盖到终点！**

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

![55.跳跃游戏](/assets/20201124154758229.png)

```cpp
class Solution {
public:
	bool canJump(vector<int>& nums) {
		int cover = 0;
		if (nums.size() == 1) return true;
        // i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。
		for (int i = 0; i <= cover; i++) {
            // 而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。
			cover = max(i + nums[i], cover);
            // 如果cover大于等于了终点下标，直接return true就可以了。
			if (cover >= nums.size() - 1) {   
				return true;
			}
		}
		return false;
	}
};
```



### 56 合并区间

#### 方法1：贪心算法

![56.合并区间](/assets/20201223200632791.png)

按照左边界从小到大排序之后，如果 `intervals[i][0] <= intervals[i - 1][1]` 即intervals[i]的左边界 <= intervals[i - 1]的右边界，则一定有重叠。（本题相邻区间也算重贴，所以是<=）

接着用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。

```cpp
class Solution {
public:
    // 按照左边界从小到大排列
	static bool cmp(const vector<int>& a, const vector<int>& b) {
		return a[0] < b[0];
	}

	vector<vector<int>> merge(vector<vector<int>>& intervals) {
		vector<vector<int>> result;
		if (intervals.size() == 0) return result;
		sort(intervals.begin(), intervals.end(), cmp);
        // 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
		result.push_back(intervals[0]);
		for (int i = 1; i < intervals.size(); i++) {
			if (result.back()[1] >= intervals[i][0]) { // 发现重叠区间
                // 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
				result.back()[1] = max(result.back()[1], intervals[i][1]);
			}
			else {
				result.push_back(intervals[i]); // 区间不重叠直接放入
			}
		}
		return result;
	}
};
```



### 738 单调递增的数字

#### 方法1：贪心算法

从前向后遍历的话，遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。

这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。

那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -> 329 -> 299

确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。

```cpp
class Solution {
public:
	int monotoneIncreasingDigits(int n) {
		string strNum = to_string(n);
        // flag用来标记赋值9从哪里开始
		int flag = strNum.size(); // 防止第二个for循环在flag没有被赋值的情况下执行
		for (int i = strNum.size() - 1; i > 0; i--) {
			if (strNum[i - 1] > strNum[i]) {
				flag = i;
				strNum[i - 1]--;
			}
		}
		for (int i = flag; i < strNum.size(); i++) {
			strNum[i] = '9';
		}
		return stoi(strNum);
	}
};
```



### 986 监控二叉树

#### 方法1：贪心算法

如果把摄像头放在叶子节点上，就浪费的一层的覆盖。所以把摄像头放在叶子节点的父节点位置，才能充分利用摄像头的覆盖面积。头结点放不放摄像头也就省下一个摄像头， 叶子节点放不放摄像头省下了的摄像头数量是指数阶别的。

**所以我们要从下往上看，局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

大体思路就是从低到上，先给叶子节点父节点放个摄像头，然后隔两个节点放一个摄像头，直至到二叉树头结点。

##### 如何隔两个节点放一个摄像头

此时需要状态转移的公式，大家不要和动态的状态转移公式混到一起，本题状态转移没有择优的过程，就是单纯的状态转移！

来看看这个状态应该如何转移，先来看看每个节点可能有几种状态：

有如下三种：

- 该节点无覆盖
- 本节点有摄像头
- 本节点有覆盖

我们分别有三个数字来表示：

- 0：该节点无覆盖
- 1：本节点有摄像头
- 2：本节点有覆盖



### 45 跳跃游戏II

#### 方法1：贪心算法

**要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！**

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。

如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。

![45.跳跃游戏II](/assets/20201201232309103.png)

**图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）**

```cpp
// 版本二
class Solution {
public:
    int jump(vector<int>& nums) {
        int curDistance = 0;    // 当前覆盖的最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖的最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) { // 注意这里是小于nums.size() - 1，这是关键所在
            nextDistance = max(nums[i] + i, nextDistance); // 更新下一步覆盖的最远距离下标
            // 移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。
            // 想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。
            if (i == curDistance) {                 // 遇到当前覆盖的最远距离下标
                curDistance = nextDistance;         // 更新当前覆盖的最远距离下标
                ans++;
            }
        }
        return ans;
    }
};
```



### 1005 K次取反后最大化的数组和

#### 方法1：贪心算法

```cpp
class Solution {
public:
	static bool cmp(int a, int b) {
		return abs(a) > abs(b);
	}

	int largestSumAfterKNegations(vector<int>& nums, int k) {
		sort(nums.begin(), nums.end(), cmp); // 第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
		for (int i = 0; i < nums.size(); i++) { // 第二步：从前向后遍历，遇到负数将其变为正数，同时K--；把数值最大的负数转为整数，可以让和最大化
			if (nums[i] < 0 && k>0) {
				nums[i] *= -1;
				k--;
			}
		}

		if (k % 2 == 1) nums[nums.size() - 1] *= -1; // 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
		int result = 0;
		for (int num : nums) result += num; // 第四步：求和
		return result;
	}
};
```



### 134 加油站

#### 方法1：贪心算法

**for循环适合模拟从头到尾的遍历，而while循环适合模拟环形遍历，要善于使用while！**

![img](/assets/20230117165628.png)

![img](/assets/20230117170703.png)

如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。

区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择其实位置了。

**那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。

```cpp
class Solution {
public:
	int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
		int curSum = 0;
		int totalSum = 0;
		int start = 0;
		for (int i = 0; i < gas.size(); i++) { 
			curSum += gas[i] - cost[i];
			totalSum += gas[i] - cost[i];
			if (curSum < 0) { // 当前累加rest[i]和 curSum一旦小于0
				start = i + 1; // 起始位置更新为i+1
				curSum = 0; // curSum从0开始
			}
		}
		if (totalSum < 0) return -1; // curSum从0开始
		return start;
	}
};
```







## 双指针

### 167 两数之和II-输入有序数组

#### 方法一：排序数组，双指针遍历方向相反

​		因为数组已经排好序，我们可以采用方向相反的双指针来寻找这两个数字，一个初始指向最小的元素，即数组最左边，向右遍历；一个初始指向最大的元素，即数组最右边，向左遍历。

- 如果两个指针指向元素的和等于给定值，那么它们就是我们要的结果。
- 如果两个指针指向元素的和小于给定值，我们把左边的指针右移一位，使得当前的和增加一点。如果两个指针指向元素的和大于给定值，我们把右边的指针左移一位，使得当前的和减少一点。

​		可以证明，对于排好序且有解的数组，双指针一定能遍历到最优解。证明方法如下：假设最优解的两个数的位置分别是 l和 r。我们假设在左指针在 l左边的时候，右指针已经移动到了 r；此时两个指针指向值的和小于给定值，因此左指针会一直右移直到到达 l。同理，如果我们假设在右指针在 r右边的时候，左指针已经移动到了 l；此时两个指针指向值的和大于给定值，因此右指针会一直左移直到到达 r。所以双指针在任何时候都不可能处于 (l,r)之间，又因为不满足条件时指针必须移动一个，所以最终一定会收敛在 l和 r

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>

vector<int> createVector() {
	vector<int> ivec;
	int num;
	do
	{
		cin >> num;
		ivec.push_back(num);
	} while (getchar() != '\n');
	return ivec;
}

void printVector(vector<int>& v) {
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

class Solution {
public:
	vector<int> twoSum(vector<int>& numbers, int target) {
		//l一开始在最左边，r在最右边
		int l = 0, r = numbers.size() - 1, sum;
		while (l < r) {
			sum = numbers[l] + numbers[r];
			if (sum == target) { //两个指针指向元素的和等于给定值，结束
				break;
			}
			if (sum < target) { //如果小了，左指针往右移
				++l;
			}
			else { //如果大了，右指针往左移
				--r;
			}
		}
		return vector<int>{ l + 1,r + 1 }; //因为下标从1开始，多加1
	}
};


int main()
{
	vector<int> numbers;
	numbers = createVector();
	int target;
	cin >> target;

	Solution ss;
	vector<int> result = ss.twoSum(numbers, target);
	cout << result[0] <<" "<<result[1] << endl;;

	system("pause");
	return 0;
}
```



### 15 三数之和

#### 方法1：双指针

```cpp
class Solution {
public:
	vector<vector<int>> threeSum(vector<int>& nums) {
		vector<vector<int>> result;
		sort(nums.begin(), nums.end());
		for (int i = 0; i < nums.size(); i++) {
			if (nums[i] > 0) {
				return result;
			}
			if (i>0 && nums[i]==nums[i-1]) {
				continue;
			}
			int left = i + 1;
			int right = nums.size() - 1;
			while (right > left) {
				if (nums[i] + nums[left] + nums[right] > 0) right--;
				else if (nums[i] + nums[left] + nums[right] < 0) left++;
				else {
					result.push_back(vector<int>{nums[i], nums[left], nums[right]});
					while (right > left && nums[right] == nums[right - 1]) right--;
					while (right > left && nums[left] == nums[left + 1])left++;
					right--;
					left++;
				}
			}
		}
		return result;
	}
};
```







### 18 四数之和

#### 方法1：双指针

```cpp
class Solution {
public:
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
		vector<vector<int>> result;
		sort(nums.begin(), nums.end());
		for (int k = 0; k < nums.size(); k++) {
			// 剪枝处理
			if (nums[k] > target && nums[k] >= 0) {
				break;
			}
			// 对nums[k]去重
			if (k > 0 && nums[k] == nums[k - 1]) {
				continue;
			}
			for (int i = k + 1; i < nums.size(); i++) {
				// 2级剪枝处理
				if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
					break;
				}
				// 对nums[i]去重
				if (i > k + 1 && nums[i] == nums[i - 1]) {
					continue;
				}
				int left = i + 1;
				int right = nums.size() - 1;
				while (right > left) {
					if ((long)nums[k] + nums[i] + nums[left] + nums[right] > target) {
						right--;
					}
					else if ((long)nums[k] + nums[i] + nums[left] + nums[right] < target) {
						left++;
					}
					else {
						result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
						// nums[left]和nums[right]去重
						while (right > left && nums[right] == nums[right - 1]) right--;
						while (right > left && nums[left] == nums[left + 1]) left++;
						// 找到答案时，双指针同时收缩
						right--;
						left++;
					}
				}
			}
		}
		return result;
	}
};
```



### 88 合并两个有序数组

#### 方法一：双指针

每次从两个数组的头部取出比较小的数字放到结果中

```cpp
#include <iostream>
using namespace std;
#include <vector>
#include <algorithm>

vector<int> createVector() {
	vector<int> ivec;
	int num;
	do
	{
		cin >> num;
		ivec.push_back(num);
	} while (getchar() != '\n');
	return ivec;
}

class Solution {
public:
	void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		//双指针
		int p1 = 0, p2 = 0;
		//创建一个新的数组，暂存排好序的数
		int *sorted=new int[m + n];
		int cur;
		while (p1 < m || p2 < n) {
			if (p1 == m) {
				cur = nums2[p2++];
			}
			else if (p2 == n) {
				cur = nums1[p1++];
			}
			else if (nums1[p1] < nums2[p2]) {
				cur = nums1[p1++];
			}
			else {
				cur = nums2[p2++];
			}
			sorted[p1 + p2 - 1] = cur;
		}
		//降排好序的数组赋给nums1
		for (int i = 0; i < m + n; ++i) {
			nums1[i] = sorted[i];
		}
		delete[] sorted;
	}
};

int main()
{
	vector<int> nums1, nums2;
	int m, n;
	nums1 = createVector();
	cin >> m;
	nums2 = createVector();
	cin >> n;

	Solution ss;
	ss.merge(nums1, m, nums2, n);

	for (int i = 0; i < m + n; ++i) {
		cout << nums1[i] << " ";
	}

	system("pause");
	return 0;
}
```



### 142 环形链表II

#### 方法一：快慢指针

对于链表找环路的问题，有一个通用的解法——快慢指针（Floyd判圈法）。

- 给定两个指针，分别命名为 slow和 fast，起始位置在链表的开头。
- 每次 fast前进两步，slow前进一步。如果 fast可以走到尽头，那么说明没有环路；
- 如果 fast可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow和 fast相遇。
- 当 slow和 fast第一次相遇时，我们将 fast重新移动到链表开头，并让 slow和 fast每次都前进一步。当 slow和 fast第二次相遇时，相遇的节点即为环路的开始点 

![1668084872360](/assets/1668084872360.png)

```cpp
class Solution {
public:
	ListNode* detectCycle(ListNode* head) {
		ListNode* slow = head, * fast = head;
		//判断还是否存在环路
		do {
			//如果存在fast为空，或者fast->next为空的情况，
			//说明fast可以走到尽头，就说明没有环路
			if (!fast || !fast->next) {
				return nullptr;
			}
			//每次fast前进两步，slow前进一步
			fast = fast->next->next;
			slow = slow->next;
		} while (fast != slow); //如果存在环路，一定存在一个时刻slow和fast相遇
		//当slow和first第一次相遇时，将fast重新移动到链表开头
		fast = head;
		while (fast != slow) { //当slow和fast第二次相遇时，相遇的节点即为环路的开始点
			//让slow和fast每次都前进一步
			slow = slow->next;
			fast = fast->next;
		}
		return fast;
	}
};
```

### 76 最小覆盖子串

#### 方法一：滑动窗口

滑动窗口机制，一个用于【延伸】现有窗口的r指针，一个用于【收缩】窗口的l指针，在任意时刻，只有一个指针运动，而另一个保持静止。

**我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。**

使用长度为128的数组来映射字符，其中chars表示目前每个字符缺少的数量，flag表示每个字符中是否在t中存在

```cpp
class Solution {
public:
	string minWindow(string S, string T) {
		vector<int> chars(128, 0);
		vector<bool> flag(128, false);
		//先统计T中的字符情况
		for (int i = 0; i < T.size(); ++i) {
			flag[T[i]] = true; //在flag中，将t字符串中字母对应的ASCII码位置为true
			++chars[T[i]]; //在chars中，将t字符串中字母对应的ASCII位上，统计相应字母的个数s
		}
		//移动滑动窗口，不断更改统计数据
		int cnt = 0, l = 0, min_l = 0, min_size = S.size() + 1;
		for (int r = 0; r < S.size(); ++r) {
			if (flag[S[r]]) {
				//对应的字母个数减1s
				if (--chars[S[r]] >= 0) {
					//cnt++，表示有一个相符
					++cnt;
				}
				//若目前滑动窗口已包含T中全部字符，
				//则尝试将l右移，在不影响结果的情况下获得最短子字符串
				while (cnt == T.size()) {
					if (r - l + 1 < min_size) {
						min_l = l;
						min_size = r - l + 1;
					}
					if (flag[S[l]] && ++chars[S[l]] > 0) {
						--cnt;
					}
					++l;
				}
			}
		}
		return min_size > S.size() ? "" : S.substr(min_l, min_size);
	}
};
```



### 438 找到字符串中所有字母异位词

#### 方法1：滑动窗口

==滑动窗口很好的题解：==[我写了一首诗，把滑动窗口算法变成了默写题 - 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/)

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        unordered_map<char, int> need, window;
        for (char c : p) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) 
                    valid++;
            }
            // 判断左侧窗口是否要收缩
            while (right - left >= p.size()) {
                // 当窗口符合条件时，把起始索引加入 res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```



### 202 快乐数

#### 方法一：快慢指针

快指针每次走两步，慢指针每次走一步，当二者相等时，即为一个循环周期。循环结束后，判断是不是1，是的话就是快乐数，否则不是快乐数。

```cpp
class Solution {
public:
	int bitSquareSum(int n) {
		int sum = 0;
		while (n > 0) {
			int bit = n % 10;
			sum += bit * bit;
			n = n / 10;
		}
		return sum;
	}

	bool isHappy(int n) {
		int slow = n, fast = n;
		do {
			slow = bitSquareSum(slow);
			fast = bitSquareSum(fast);
			fast = bitSquareSum(fast);
		} while (slow != fast);

		return slow == 1;
	}
};
```



### 27 移除元素

#### 方法1：双指针法（快慢指针）

![27.移除元素-双指针法](/assets/23412hsdjfhaw.gif)

- 快指针：寻找新数组的元素，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.size(); fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                ++slow;
            }
        }
        return slow;
    }
};
```



### 977 有序数组的平方

#### 方法1：双向指针

![img](/assets/234hasjhdfawer1234234124.gif)

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int m = nums.size() - 1;
        vector<int> ans(nums.size(), 0);
        int i = 0;
        int j = nums.size() - 1;
        while (i <= j) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                ans[m--] = nums[j] * nums[j];
                --j;
            }
            else {
                ans[m--] = nums[i] * nums[i];
                ++i;
            }
        }
        return ans;
    }
};
```

### 209 长度最小的子数组

#### 方法1：滑动窗口

在本题中实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![leetcode_209](/assets/20210312160441942.png)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = nums.size();
        int ans =INT_MAX;
        int sum = 0; // 滑动窗口数值之和
        int l = 0; // 滑动窗口起始位置
        for (int r = 0; r < len; ++r) {
            sum += nums[r];
            // 注意这里使用while，每次更新 l（起始位置），并不断比较子序列是否符合条件
            while (sum >= target) {
                int sublength = (r - l + 1); // 取子序列的长度
                ans = ans < sublength ? ans : sublength;
                sum -= nums[l++]; // 这里体现出滑动窗口的精髓之处，不断变更l（子序列的起始位置）
            }
        }
        // ans没有被赋值的话，就返回0，说明没有符合条件的子序列
        return ans == INT_MAX ? 0 : ans;
    }
};
```



### 3 无重复字符的最长子串

#### 方法1：滑动窗口

```cpp
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		if (s.size() == 0) return 0;
		unordered_set<char> lookup;
		int maxStr = 0;
		int left = 0;
		for (int i = 0; i < s.size(); i++) {
			while (lookup.find(s[i]) != lookup.end()) {
				// 找到了，移动队列并把队列左边的元素移出
				lookup.erase(s[left]);
				left++;
			}
			// 一直找出队列最长的长度
			maxStr = max(maxStr, i - left + 1);
			lookup.insert(s[i]);
		}
		return maxStr;
	}
};
```



### 11 盛最多水的容器

#### 方法1：双指针

此题的面积公式：
$$
s(i,j)=min(h[i],h[j])*(j-1)
$$
![1678785485854](/assets/1678785485854.png)

因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() - 1, res = 0;
        while (i < j) {
            if (height[i] < height[j]) {
                res = max(res, (j - i) * height[i++]);
            }
            else {
                res = max(res, (j - i) * height[j--]);
            }
        }
        return res;
    }
};
```



#### 287 寻找重复数

#### 方法1：快慢指针

1.数组中有一个重复的整数 <=> 链表中存在环
2.找到数组中的重复整数 <=> 找到链表的环入口

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0;
        int fast = 0;
        slow = nums[slow];
        fast = nums[nums[fast]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }

        int pre1 = 0;
        int pre2 = slow;
        while (pre1 != pre2) {
            pre1 = nums[pre1];
            pre2 = nums[pre2];
        }
        return pre1;
    }
};

```



### 925 长按键入

#### 方法1：双指针

```cpp
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        if(typed.size()<name.size()) return false;
        int i=0,j=0;
        int lenName=name.size(),lenTyped=typed.size();
        while(i<lenName && j< lenTyped){
            // 如果相同就都移动，如果不同就只移动typed
            if(name[i]==typed[j]){
                ++i;
                ++j;
            }
            else{
                ++j;
            }
        }

        if(i==lenName && j<=lenTyped){
            return true;
        }
        else{
            return false;
        }
    }
};
```



## 二分查找

### 69 x的平方根

#### 方法一：二分查找

```cpp
//最简单的的题目有自己做出来
class Solution {
public:
	int mySqrt(int x) {
		long low = 1, high = x; //防止int越界，long的取值范围大一点
		while (low <= high) {
			long mid = (low + high) / 2;
			if (mid* mid <= x) {
				if ((mid + 1) * (mid + 1) > x) {
					return mid; //此时的mid的平方小于等于x，但是加1后会大于x
				}
				
			}
			if (mid * mid < x) { 
				low = mid + 1;
			}
			if (mid * mid > x) {
				high = mid - 1;
			}
		}
		return 0;
	}
};
```

### 34 在排序数组中查找元素的第一个和最后一个位置

#### 方法 一：二分查找

找数组中【第一个等于target的位置】和【第一个大于target的位置减一】

```cpp
#include <iostream>
using namespace std;
#include <vector>

vector<int> createVector() {
	vector<int> ivec;
	int num;
	do
	{
		cin >> num;
		ivec.push_back(num);
	} while (getchar() != '\n');
	return ivec;
}

class Solution {
public:
	vector<int> searchRange(vector<int>& nums, int target) {
		//找第一个大于等于target的位置
		int low = 0, high = nums.size();
		while (low < high) {
			int mid = (low + high) / 2;
			
			if (target <= nums[mid]) {
				high = mid;
			}
			else {
				low = mid + 1;
			}
		}
		int lower = low;

		//找第一个大于target的位置减一
		low = 0, high = nums.size();
		while (low < high) {
			int mid = (low + high) / 2;
			if (nums[mid] > target) {
				high = mid;
			}
			else {
				low = mid + 1;
			}
		}
		int upper = low - 1;
		if (nums.empty()) {
			return vector<int>{-1, -1};
		}
		if (lower == nums.size() || nums[lower] != target) {
			return vector<int>{-1, -1};
		}
		return vector<int>{lower, upper};
	}
};


int main()
{
	vector<int> nums;
	int target;
	
	nums = createVector();
	cin >> target;

	Solution ss;
	vector<int> pos = ss.searchRange(nums, target);
	for (int i = 0; i < pos.size(); ++i) {
		cout << pos[i] << " ";
	}

	system("pause");
	return 0;
}
```

### 81 搜索旋转排序数组II

#### 方法一：二分查找

```cpp
class Solution {
public:
	bool search(vector<int>& nums, int target) {
		int l = 0, r = nums.size() - 1;
		while (l <= r) {
			int mid = l + (r - l) / 2;
			if (nums[mid] == target) {
				return true;
			}
			if (nums[l] == nums[mid]) {
				//无法判断哪个区间是增序的
				++l;
			}
			else if (nums[r] == nums[mid]) {
				//无法判断哪个区间是增序的
				--r;
			}
			else if (nums[mid] < nums[r]) {
				//右区间是增序的
				if (target > nums[mid] && target <= nums[r]) {
					l = mid + 1;
				}
				else {
					r = mid - 1;
				}
			}
			else {//左区间是增序的
				if (target >= nums[l] && target < nums[mid]) {
					r = mid - 1;
				}
				else {
					l = mid + 1;
				}
			}
		}
		return false;
	}
};

```

#### 方法二：顺序查找

```cpp
class Solution {
public:
	bool search(vector<int>& nums, int target) {
		for (int i = 0; i < nums.size(); ++i) {
			if (nums[i] == target) {
				return true;
			}
		}
		return false;
	}
};
```

### 704 二分查找

左闭右开，用小于<

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```



### 33 搜索旋转数组

#### 方法1：二分查找

我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。

![1678799640952](/assets/1678799640952.png)

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if (n == 0) return -1;
        if (n == 1) return nums[0] == target ? 0 : -1;
        int l = 0;
        int r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            // 第一种情况
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                }
                else {
                    l = mid + 1;
                }
            }
            // 第二种情况
            else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                }
                else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};

```



### 240 搜索二维矩阵

#### 方法1：二分查找

一行一行去执行二分查找

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        for (int i = 0; i < m; i++) {
            // 左闭右闭的二分查找
            int l = 0;
            int r = n - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (matrix[i][mid] == target) return true;
                else if (matrix[i][mid] < target) {
                    l = mid + 1;
                }
                else if (matrix[i][mid] > target) {
                    r = mid - 1;
                }
            }
        }
        return false;
    }
};
```



## 排序算法

### 215 数组中的第K个最大元素

#### 方法一：快速排序

```cpp
//快速排序
void quick_sort(vector<int>& nums, int l, int r) {
	if (l + 1 >= r) {
		return;
	}
	int first = l, last = r - 1, key = nums[first];
	while (first < last) {
		while (first < last && nums[last] >= key) {
			--last;
		}
		nums[first] = nums[last];
		while (first < last && nums[first] <= key) {
			++first;
		}
		nums[last] = nums[first];
	}
	nums[first] = key;
	quick_sort(nums, l, first);
	quick_sort(nums, first + 1, r);
}

class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		quick_sort(nums, 0, nums.size());
		return nums[nums.size() - k];
	}
};
```

#### 方法二：sort排序

```cpp
class Solution {
public:
	int findKthLargest(vector<int>& nums, int k) {
		sort(nums.begin(),nums.end());
		return nums[nums.size() - k];
	}
};
```

### 347 前K个高频元素

#### 方法一：桶排序

```cpp
class Solution {
public:
	vector<int> topKFrequent(vector<int>& nums, int k) {
		unordered_map<int, int> counts;
		int max_count = 0;
		//查找最大频次
		//根据每个数的频次放入unordered_map容器 1:4, 2:2, 3:1, 4:1
		for (const int& num : nums) {
			max_count = max(max_count, ++counts[num]);
		}
		//按照频次建立4个新桶，4:[3,4], 2:[2], 3:[1], 4:[1]
		vector<vector<int>> buckets(max_count + 1);
		for (const auto& p : counts) {
			buckets[p.second].push_back(p.first);
		}
		//从后往前遍历，直到找到k个频次最高的桶
		vector<int> ans;
		for (int i = max_count; i >= 0 && ans.size() < k; --i) {
			for (const int& num : buckets[i]) {
				ans.push_back(num);
				if (ans.size() == k) {
					break;
				}
			}
		}
		return ans;
	}
};
```



### 532 数组中的k-diff数对

#### 方法1：排序+二分查找

```cpp
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        int n=nums.size(),res=0;
        // 对数组进行排序
        sort(nums.begin(),nums.end());
        // 从左到右比遍历，在[i+1，n-1]的范围内二分查找nums[i]+k是否存在即可
        for(int i=0;i<n-1;i++){
            // 重复的不计算
            if(i>0 && nums[i]==nums[i-1]){
                continue;
            }
            int target=nums[i]+k;
            int left=i+1,right=n-1;
            int ans=-1;
            while(left<=right){
                int mid=left+(right-left)/2;
                if(nums[mid]>=target){
                    ans=mid;
                    right=mid-1;
                }
                else{
                    left=mid+1;
                }
            }
            // 判断是否找到
            if(ans!=-1 && nums[ans]==target){
                res++;
            }
        }
        return res;
    }
};
```



## 搜索

### 695 岛屿的最大面积

#### 方法一：深度优先搜索

创造一个数组 [-1, 0, 1, 0, -1]，每相邻两位为上下左右四个方向之一，(-1,0):left, (0,1):up, (1,0):right, (0,-1):down。

辅助函数内递归搜索时，判断是否越界，只有在合法的情况下才进行

```cpp
class Solution {
public:
	//(-1,0):left, (0,1):up, (1,0):right, (0,-1):down
	vector<int> direction{ -1,0,1,0,-1 };

	// 主函数
	int maxAreaOfIsland(vector<vector<int>>&grid) {
		if (grid.empty() || grid[0].empty()) return 0;
		int max_area = 0;
		for (int i = 0; i < grid.size(); ++i) {
			for (int j = 0; j < grid[0].size(); ++j) {
				//如果单元格为1，才进行广度优先搜索
				if (grid[i][j] == 1) {
					max_area = max(max_area, dfs(grid, i, j));
				}
			}
		}
		return max_area;
	}
	//辅函数
	int dfs(vector<vector<int>>& grid, int r, int c) {
		if (grid[r][c] == 0) return 0;
		grid[r][c] = 0;
		int x, y, area = 1;
		for (int i = 0; i < 4; ++i) {
			x = r + direction[i], y = c + direction[i + 1];
			//边界条件判定，合法了才进行下一步搜索
			if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size()) {
				area += dfs(grid, x, y);
			}
		}
		return area;
	}
};
```



### 543 二叉树的直径

#### 方法1：深度优先搜索

![1678699173415](/assets/1678699173415.png)

```cpp
class Solution {
public:
    int ans;
    int depth(TreeNode* root) {
        if (root == nullptr) return 0;

        int left = depth(root->left);
        int right = depth(root->right);
        // 以该节点为起点的路径经过节点数的最大值为ans
        ans = max(ans, left + right + 1);
        // 以该节点为根的子树深度
        return max(left, right) + 1;

    }

    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        depth(root);
        return ans-1;
    }
};
```



### 46 全排列

#### 方法一：回溯法

对于每一个当前位置 i，我们可以将其于之后的任意位置交换，然后继续处理位置 i+1，直到处理到最后一位。为了防止我们每此遍历时都要新建一个子数组储存位置 i之前已经交换好的数字，我们可以利用回溯法，只对原数组进行修改，在递归完成后再修改回来。

```cpp
void backtracking(vector<int>& nums, int level, vector<vector<int>>& ans) {
	if (level == nums.size() - 1) {
		ans.push_back(nums);
		return;
	}
	for (int i = level; i < nums.size(); ++i) {
		swap(nums[i], nums[level]);
		backtracking(nums, level + 1, ans);
		swap(nums[i], nums[level]);
	}
}

class Solution {
public:
	vector<vector<int>> permute(vector<int>& nums) {
		vector<vector<int>> ans;
		backtracking(nums, 0, ans);
		return ans;
	}
};
```



### 200 岛屿数量

#### 方法1：DFS

最好的网格DFS：[岛屿类问题的通用解法、DFS 遍历框架 - 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/)

```cpp
class Solution {
public:
    // 0-海洋格子
    // 1-陆地格子（未遍历过）
    // 2-陆地格子（遍历过）
    int numIslands(vector<vector<char>>& grid) { 
        int res = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                // 未遍历过的地方才遍历
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }

    void dfs(vector<vector<char>>& grid, int r, int c) {
        // 判断边界条件
        if (r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()) {
            return;
        }
		// 如果这个格子不是岛屿，直接返回
        if (grid[r][c] != '1') {
            return;
        }

        grid[r][c] = '2'; // 将格子标记为遍历过
        // 访问上、下、左、右四个相邻结点
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }
};
```







## 动态规划

### 70 爬楼梯

#### 方法一：动态规划

斐波那契数列

状态转移方程：dp[i]=dp[i-1]+dp[i-2]

1. 确定dp数组（dp table）以及下标的含义：
   dp[i]： 爬到第i层楼梯，有dp[i]种方法

2. 确定递推公式：

   首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

   还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

   那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

   所以dp[i] = dp[i - 1] + dp[i - 2] 。

3. dp数组如何初始化：
   dp[1] = 1，dp[2] = 2，然后从i = 3开始递推

4. 确定遍历顺序：
   从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导dp数组：
   

```cpp
class Solution {
public:
	int climbStairs(int n) {
		if (n <= 2) {
			return n;
		}
		int first = 1, two = 2; //定义两个子问题的解
		int cur;
		for (int i = 3; i <= n; ++i) {
			cur = first + two; //当前问题的解等于两个子问题的解之和
			first = two;
			two = cur;
		}
		return cur;
	}
};
```

#### 方法2：完全背包

```
1.确定dp数组以及下标的含义
dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。

2.确定递推公式
求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];
dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]
递推公式为：dp[i] += dp[i - j]

3.dp数组如何初始化
递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。
下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果

4.确定遍历顺序
这是背包里求排列问题，即：1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！
需将target放在外循环，将nums放在内循环。
每一步可以走多次，这是完全背包，内循环需要从前向后遍历。


```

```cpp
class Solution {
public:
	int climbStairs(int n) {
		vector<int> dp(n + 1, 0);
		dp[0] = 1;
       	// 背包容量不会为0
		for (int i = 1; i <= n; i++) {
            // 不会走0阶台阶
			for (int j = 1; j <= 2; j++) {
				if (i - j >= 0) dp[i] += dp[i - j];
			}
		}
		return dp[n];
	}
};
```



### 322 零钱兑换

#### 方法1：完全背包

```
1.确定dp数组以及下标的含义
dp[j]：凑足总额为j所需钱币的最少个数为dp[j]

2.确定递推公式
凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。
递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

3.p数组如何初始化
首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;
考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。
所以下标非0的元素都是应该是最大值。

4.确定遍历顺序
本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。
本题并不强调集合是组合还是排列。
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。

本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序
综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。
```

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                // j在双层for循环里表示的是背包，所以是j-coins[i]
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```



### 279 完全平方数

#### 方法1：完全背包

```
完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？

1.确定dp数组（dp table）以及下标的含义
dp[j]：和为j的完全平方数的最少数量为dp[j]

2.确定递推公式
dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。
此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);

3.dp数组如何初始化
dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。
从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。

4.确定遍历顺序
我们知道这是完全背包，
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
本题是求最小数，无所谓。
```

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) { // 遍历物品
            for (int j = i * i; j <= n; j++) { // 遍历背包
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```



### 139 单词拆分

#### 方法1：完全背包

```cpp
单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。
拆分时可以重复使用字典中的单词，说明就是一个完全背包！

1.确定dp数组以及下标的含义
dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。

2.确定递推公式
如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。
所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

3.dp数组如何初始化
从递推公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递推的根基，dp[0]一定要为true，否则递推下去后面都都是false了。
“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。
下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4.确定遍历顺序
完全背包问题，跟顺序有关
所以本题一定是先遍历背包，再遍历物品

```

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```





### 746 使用最小花费爬楼梯

#### 方法1：动态规划

1. 确定dp数组以及下标的含义

   **dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。

2. 确定递推公式

   dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

   dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

   选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])

3. dp数组如何初始化

   可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯

   初始化 dp[0] = 0，dp[1] = 0

4. 确定遍历顺序

   因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。

5. 举例推导dp数组

   ![img](/assets/20221026175104.png)

```cpp
class Solution {
public:
	int minCostClimbingStairs(vector<int>& cost) {
		vector<int> dp(cost.size() + 1);
		dp[0] = 0;
		dp[1] = 2;
		for (int i = 2; i <= cost.size(); i++) {
			dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
		}
		return dp[cost.size()];
	}
};
```



### 198 打家劫舍

#### 方法一：动态规划

​		定义一个数组 dp，dp[i] 表示抢劫到第 i 个房子时，可以抢劫的最大数量。我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。因此本题的状态转移方程为 dp[i] = max(dp[i-1], nums[i-1] + dp[i-2])。

```cpp
class Solution {
public:
	int rob(vector<int>& nums) {
		int len = nums.size();
		if (nums.empty()) {
			return 0;
		}
		if (len == 1) {
			return nums[0];
		}
		int first = 0, two = 0;
		int cur = 0;
		for (int i = 0; i < len; ++i) {
			cur = max(two, first + nums[i]);
			first = two;
			two = cur;
		}
		return cur;
	}
};
```



#### 方法2：动态规划 代码随想录

```
当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。
当前状态和前面状态会有一种依赖关系，那么这种依赖关系都是动规的递推公式。

1.确定dp数组（dp table）以及下标的含义
dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。

2.确定递推公式
决定dp[i]的因素就是第i房间偷还是不偷。
如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。
如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）
然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

3.dp数组如何初始化
从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]
从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

4.确定遍历顺序
dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！
```

```cpp
class Solution {
public:
	int rob(vector<int>& nums) {
		if (nums.size() == 0) return 0;
		if (nums.size() == 1) return nums[0];
		vector<int> dp(nums.size());
		dp[0] = nums[0];
		dp[1] = max(nums[0], nums[1]);
		for (int i = 2; i < nums.size(); i++) {
			dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
		}
		return dp[nums.size() - 1];
	}
};
```



### 213 打家劫舍II

#### 方法1：动态规划

```cpp
class Solution {
public:
	int rob(vector<int>& nums) {
		if (nums.size() == 0) return 0;
		if (nums.size() == 1) return nums[0];
        // 在不偷窃最后一个房子的情况下和不偷窃最后一个房子的情况下，取最大的那一个
		int result1 = robRange(nums, 0, nums.size() - 2);
		int result2 = robRange(nums, 1, nums.size() - 1);
		return max(result1, result2);
	}

	int robRange(vector<int>& nums, int start, int end) {
		if (start == end) return nums[start];
		vector<int> dp(nums.size());
		dp[start] = nums[start];
		dp[start + 1] = max(nums[start], nums[start + 1]);
		for (int i = start + 2; i <= end; i++) {
			dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
		}
		return dp[end];
	}
};
```



### 337 打家劫舍III

#### 方法1：动态规划

```
1.确定递归函数的参数和返回值
这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。
vector<int> robTree(TreeNode* cur)
这里的返回数组就是dp数组。
所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。
## 在递归的过程中，系统栈会保存每一层递归的参数

2.确定终止条件
在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回
if (cur == NULL) return vector<int>{0, 0};
```

```
3.确定遍历顺序
首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。
通过递归左节点，得到左节点偷与不偷的金钱。
通过递归右节点，得到右节点偷与不偷的金钱。

// 下标0：不偷，下标1：偷
vector<int> left = robTree(cur->left); // 左
vector<int> right = robTree(cur->right); // 右
// 中
```

```
4.确定单层递归的逻辑
如果是偷当前节点，那么左右孩子就不能偷，val1 = cur->val + left[0] + right[0]; （如果对下标含义不理解就再回顾一下dp数组的含义）
如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 = max(left[0], left[1]) + max(right[0], right[1]);
最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}
```

![img](/assets/20230203110031.png)

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```





### 62 不同路径

#### 方法1：动态规划

![62.不同路径1](/assets/20201209113631392-1678241293953.png)

```cpp
class Solution {
public:
	int uniquePaths(int m, int n) {
        // dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
		vector<vector<int>> dp(m, vector<int>(n, 0));
        // 初始化，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。
		for (int i = 0; i < m; i++) {
			dp[i][0] = 1;
		}
		for(int j=0;j<n;j++){
			dp[0][j] = 1;
		}
        // 递推公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
                // dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```



### 63 不同路径II

#### 方法1：动态规划

有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)

![63.不同路径II1](/assets/20210104114548983.png)

![63.不同路径II2](/assets/20210104114610256.png)

```cpp
class Solution {
public:
	int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		int n = obstacleGrid[0].size();
		if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) return 0;
		vector<vector<int>> dp(m, vector<int>(n, 0));
        // 首行和首列，有障碍的地方保持初始值为0
		for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
		for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
		for (int i = 1; i < m; i++) {
			for (int j = 1; j < n; j++) {
				if (obstacleGrid[i][j] == 1) continue; // 有障碍直接跳过，不推导
				dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
			}
		}
		return dp[m - 1][n - 1];
	}
};
```





### 343 整数拆分

#### 方法1：动态规划

拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                // 有两种渠道得到dp[i]
                // 一个是j * (i - j) 直接相乘
                // 一个是j * dp[i - j]，相当于是拆分(i - j)
                // 每次计算dp[i]，取最大的而已
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```



### 96 不同的二叉搜索树

#### 方法1：动态规划

1. 确定dp数组（dp table）以及下标的含义
   **dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。
2. 确定递推公式
   dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]。==j相当于是头结点的元素==，从1遍历到i为止。
   所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
3. 初始化：dp[0]=1
4. 确定遍历顺序
   遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。
   遍历i里面每一个数作为头结点的状态，用j来遍历

```cpp
class Solution {
public:
	int numTrees(int n) {
		vector<int> dp(n + 1);
		dp[0] = 1;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; i <= i; j++) {
                // j-1为以j为头结点左子树节点数量，i-j为以j为头结点右子树节点数量
				dp[i] += dp[j - 1] * dp[i - 1];
			}
		}
		return dp[n];
	}
};
```



### 416 分割等和子集

#### 方法1：动态规划

只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了。

要注意题目描述中商品是不是可以重复放入。**一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包。**本题使用01背包，因为元素只能用一次。

**只有确定了如下四点，才能把01背包问题套到本题上来。**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

1. 确定dp数组以及下标的含义
   01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。本题中每一个元素的数值既是重量，也是价值。**dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]**。如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 ==dp[target] == target 的时候，背包就装满了。==
2. 确定递推公式
   01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);   dp[j - weight[i]] 为背包容量为j - weight[i]时，所背物品的最大价值，加上value[i]就是背包放物品i得到的最大价值
   相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。
   所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
3. dp数组如何初始化
   只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了
4. 确定遍历顺序
   如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        // 开始 01背包
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};
```



### 1049 最后一块石头的重量II

#### 方法1：动态规划，01背包

1. 确定dp数组以及下标的含义
   石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”
2. 确定递推公式
   01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
   本题则是：**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**
3. dp数组如何初始化
   重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。
4. 确定遍历顺序
   如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！
5. 举例推导dp数组

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        int target = sum / 2;
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        
        // 在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的。
        return sum - dp[target] - dp[target];
    }
};
```



### 413 等差数列划分

#### 方法一：动态规划

​		这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。

```cpp
class Solution {
public:
	int numberOfArithmeticSlices(vector<int>& nums) {
		int n = nums.size();
		if (n < 3) {
			return 0;
		}
		vector<int> dp(n, 0);
		//从第3个数开始研究
		for (int i = 2; i < n; ++i) {
			if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {
				dp[i] = dp[i - 1] + 1;
			}
		}
		return accumulate(dp.begin(), dp.end(), 0);
	}
};
```



### 494 目标和

#### 方法1：动态规划

假设加法的总和为x，那么减法对应的总和就是sum - x。所以我们要求的是 x - (sum - x) = target，x = (target + sum) / 2，**此时问题就转化为，装满容量为x的背包，有几种方法**。

1. 确定dp数组以及下标的含义
   dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
2. 确定递推公式
   只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。
   dp[j] += dp[j - nums[i]]
3. dp数组如何初始化
4. 确定遍历顺序
   nums放在外循环，target在内循环，且内循环倒序。

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```







### 64 最小路径和

#### 方法一：动态规划

​		我们可以定义一个同样是二维的 dp数组，其中 dp\[i\]\[j\]表示从左上角开始到 (i, j)位置的最优路径的数字和。因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp\[i\]\[j\] =min(dp\[i-1\]\[j\], dp\[i]\[j-1\]) + grid\[i\]\[j\]，其中 grid表示原数组。

```cpp
class Solution {
public:
	int minPathSum(vector<vector<int>>& grid) {
		int m = grid.size();
		int n = grid[0].size();
		vector<vector<int>> dp(m, vector<int>(n, 0));
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < n; ++j) {
				if (i == 0 && j == 0) {
					dp[i][j] = grid[i][j];
				}
				else if (i == 0) {
					dp[i][j] = dp[i][j - 1] + grid[i][j];
				}
				else if (j == 0) {
					dp[i][j] = dp[i - 1][j] + grid[i][j];
				}
				else {
					dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
				}
			}
		}
		return dp[m - 1][n - 1];
	}
};
```



### 509 斐波那契数

#### 方法1：动态规划

```cpp
class Solution {
public:
	int fib(int n) {
		if (n <= 1) return n;
		int dp[2];
        // 初始值
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= n; i++) {
            // 递推公式，状态转移方程
			int sum = dp[0] + dp[1];
			dp[0] = dp[1];
			dp[1] = sum;
		}
		return dp[1];
	}
};
```



### 474 一和零

#### 方法1：动态规划

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for (string str : strs) { // 遍历物品
            int zeroNum = 0, oneNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }

            // dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。
            // dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。
            // 在遍历的过程中，取dp[i][j]的最大值。
            // 所以递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
            // 本题中，物品就是strs里的字符串，背包容量就是题目描述中的m和n。
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum;j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }

        }
        return dp[m][n];
    }
};
```



### 518 零钱兑换II

#### 方法1：动态规划

```text
1.确定dp数组以及下标的含义
dp[j]：凑成总金额j的货币组合数为dp[j]

2.确定递推公式
dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。
所以递推公式：dp[j] += dp[j - coins[i]];
## 求装满背包有几种方法，公式都是：dp[j] += dp[j - nums[i]];

3.dp数组如何初始化
首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。如果dp[0] = 0 的话，后面所有推导出来的值都是0了。
那么 dp[0] = 1 有没有含义，其实既可以说 凑成总金额0的货币组合数为1，也可以说 凑成总金额0的货币组合数为0.
下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]。
## dp[0]=1还说明了一种情况：如果正好选了coins[i]后，也就是j-coins[i] == 0的情况表示这个硬币刚好能选，此时dp[0]为1表示只选coins[i]存在这样的一种选法。
```



### 377 组合总和II

#### 方法1：动态规划

```text
1.确定dp数组以及下标的含义
dp[i]: 凑成目标正整数为i的排列个数为dp[i]

2.确定递推公式
dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。
因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。
## 求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];本题也一样。

3.dp数组如何初始化
因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。
至于dp[0] = 1 有没有意义呢？
所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。
至于非0下标的dp[i]应该初始为多少呢？初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。

3.确定遍历顺序
个数可以不限使用，说明这是一个完全背包。
得到的集合是排列，说明需要考虑元素之间的顺序。

本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。
如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！
所以本题遍历顺序最终遍历顺序：target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历。
```

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                // C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```



### 300 最长递增子序列

#### 方法1：动态规划

```
1.dp[i]的定义
dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度

2.状态转移方程
位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

3.dp[i]的初始化
每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1.

4.确定遍历顺序
dp[i] 是有0到i-1各个位置的最长递增子序列 推导而来，那么遍历i一定是从前向后遍历。
j其实就是遍历0到i-1，那么是从前到后，还是从后到前遍历都无所谓，只要吧 0 到 i-1 的元素都遍历了就行了。 所以默认习惯 从前向后遍历。
```

```cpp
class Solution {
public:
	int lengthOfLIS(vector<int>& nums) {
		if (nums.size() <= 1) return nums.size();
		vector<int> dp(nums.size(), 1);
		int result = 0;
		for (int i = 1; i < nums.size(); i++) {
			for (int j = 0; j < i; j++) {
				if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
			}
			if (dp[i] > result) result = dp[i];
		}
		return result;
	}
};
```



### 674 最长连续递增序列

#### 方法1：动态规划

```
1.确定dp数组（dp table）以及下标的含义
dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]。

2.确定递推公式
如果 nums[i] > nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。
即：dp[i] = dp[i - 1] + 1;
因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。
一层for循环即可

3.p数组如何初始化
以下标i为结尾的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。
所以dp[i]应该初始1;

```

```cpp
class Solution {
public:
	int findLengthOfLCIS(vector<int>& nums) {
		if (nums.size() <= 1) return nums.size();
		int result = 1;
		vector<int> dp(nums.size(), 1);
		for (int i = 1; i < nums.size(); i++) {
			if (nums[i] > nums[i - 1]) {
				dp[i] = dp[i - 1] + 1;
			}
			if (dp[i] > result) result = dp[i];
		}
		return result;
	}
};
```



### 718 最长重复子数组

#### 方法1：动态规划

```
1.确定dp数组（dp table）以及下标的含义
dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。

2.确定递推公式
根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。
即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;
根据递推公式可以看出，遍历i 和 j 要从1开始！

3.dp数组如何初始化
根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！
dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] = dp[i - 1][j - 1] + 1;所以dp[i][0] 和dp[0][j]初始化为0。

4.确定遍历顺序
外层for循环遍历A，内层for循环遍历B。没差
```

```cpp
class Solution {
public:
	int findLength(vector<int>& nums1, vector<int>& nums2) {
		vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1, 0));
		int result = 0;
		for (int i = 1; i <= nums1.size(); i++) {
			for (int j = 1; j <= nums2.size(); j++) {
				if (nums1[i - 1] == nums2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
				if (dp[i][j] > result) result = dp[i][j];
			}	
		}
		return result;
	}
};
```



### 647 回文子串

#### 方法1：动态规划

```
1.确定dp数组（dp table）以及下标的含义
在判断字符串S是否是回文，那么如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。
判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。
布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。

2.确定递推公式
当s[i]与s[j]不相等，dp[i][j]一定是false。
当s[i]与s[j]相等时：
    情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
    情况二：下标i 与 j相差为1，例如aa，也是回文子串
    情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。
    
3. dp数组如何初始化
一开始多不匹配，dp[i][j]初始化为false。

4.确定遍历顺序
如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。
所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的。
```

![647.回文子串](/assets/20210121171032473-20230310132134822.jpg)

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        // 先遍历行，在遍历列
        for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```







### 1143 最长公共子序列

#### 方法1：动态规划

```
1.确定dp数组（dp table）以及下标的含义
dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
i-1和j-1 简化了dp数组第一行和第一列的初始化逻辑。

2.确定递推公式
主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同
如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;
如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。
即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);

3.dp数组如何初始化
先看看dp[i][0]应该是多少呢？
test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0;
同理dp[0][j]也是0。
其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。
```

```cpp
class Solution {
public:
	int longestCommonSubsequence(string text1, string text2) {
		vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
		for (int i = 1; i <= text1.size(); i++) {
			for (int j = 1; j <= text2.size(); j++) {
				if (text1[i - 1] == text2[j - 1]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
				else {
					dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
				}
			}
		}
		return dp[text1.size()][text2.size()];
	}
};
```



### 5 最长回文子串

#### 方法1：动态规划

```cpp
class Solution {
public:
	string longestPalindrome(string s) {
		int n = s.size();
		if (s.size() <= 1) return s;

		int maxLen = 1; int begin = 0;
         // 1.状态定义：dp[i][j] 表示 s[i..j] 是否是回文串
		vector<vector<int>> dp(n, vector<int>(n));
        // 2.初始化：所有长度为 1 的子串都是回文串
		for (int i = 0; i < n; i++) {
			dp[i][i] = true;
		}

        // 递推开始
        // 先枚举子串长度
		for (int L = 2; L <= n; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
			for (int i = 0; i < n; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
				int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
				if (j >= n) break;
                
                // 相等的情况下
                // 考虑头尾去掉以后没有字符剩余，或者剩下一个字符的时候，肯定是回文串
				if (s[i] != s[j]) {
					dp[i][j] = false;
				}
				else {
					if (j - i < 3) {
						dp[i][j] = true;
					}
					else {
                        // 状态转移
						dp[i][j] = dp[i + 1][j - 1];
					}
				}

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，
                // 此时记录回文长度和起始位置
				if (dp[i][j] && j - i + 1 > maxLen) {
					maxLen = j - i + 1;
					begin = i;
				}
			}
		}

		return s.substr(begin, maxLen);
	}
};
```



### 22 括号生成

#### 方法1：动态规划

```
1.确定dp数组（dp table）以及下标的含义
dp[i]表示i时的括号组，考虑i=n时相比n-1组括号增加的那一组括号的位置

2.确定递推公式
i等于n时增加的那组括号为"("   ")"
"(" + 【i=p时所有括号的排列组合】 + ")" + 【i=q时所有括号的排列组合】
p+q=n-1

3.dp数组如何初始化
dp[0] = { "" };
dp[1] = { "()" };

4.遍历顺序

```



### 309 最佳买满股票时机含冷冻期

#### 方法1：动态规划

```cpp
// 思路：
//     考虑有多少种状态，每种状态有哪些选择，或者是做了哪些选择后得到哪种状态。
//     注意：到底是先选择了才有状态，还是先由状态才能选择。这里是先选择了，才有状态

// 状态类型有2种：天数和是否持有。
//     天数：一共为1-n天
//     是否持有：分为持有状态、没持有状态1、没持有状态2。
//         持有状态：选择 无处理 和 买入 都有可能达到该状态
//         没持有状态1：选择 无处理 后达到该状态。
//         没持有状态2：选择 卖出 后达到该状态。注意，卖出后进入一天的冻结期。
//     注意：这里为什么要分两种没持有状态，这是为了便于后续状态转移，如果不区分这两种状态，状态转移没法确定当天是否可以进行买入操作。

// dp表示的含义：
//     dp[i][2] : 第i天为没持有状态2时，此时的最大利润
//     dp[i][1] : 第i天为没持有状态1时，此时的最大利润
//     dp[i][0] ： 第i天为持有状态时，此时的最大利润
// 状态转移方程：
//     dp[i][0]: 第i天为持有状态时，此时的最大利润
//         无处理后达到该状态： dp[i][0] = dp[i-1][0] // 第i天没有处理就持有股票，证明上一天也持有
//         买入后达到该状态： dp[i][0] = dp[i-1][1]-prices[n] // 第i天能买入股票，证明上一天没持有股票，且没进行卖出操作
//         所以dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[n]); // 这里思考个问题，两种情况都能到达这个状态的话，那如何选择？为什么是取他们的max？
//     dp[i][1]: 第i天为没持有状态1时，此时的最大利润
//         无处理后达到该状态： dp[i][1] = max(dp[i-1][1], dp[i-1][2]) // 有两种到达该状态的情况，取最大那个
//     dp[i][2]: 第i天为没持有状态2时，此时的最大利润
//         卖出后达到该状态： dp[i][2] = dp[i-1][0]+prices[i]

// 最后max(dp[n-1][1], dp[n-1][2])就是题目所需答案。即第n-1天没持有股票时的最大收益

// test case: 
// [1,2,3,0,2]
// [1,2,-2,0,33,0,2]
// [1,2,3,0,2,3,9,0,2,4]
// [2,1]
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1)
            return 0;
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(3));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0; // 假设默认持有0元股票
        for(int i=1; i<n; ++i){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][2]);
            dp[i][2] = dp[i-1][0] + prices[i];
        }

        return max(dp[n-1][1], dp[n-1][2]);
    }
};
```



### 221 最大正方形

#### 方法1：动态规划

![1679132988168](/assets/1679132988168.png)

```cpp
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size()==0) {
            return 0;
        }
        int maxSide = 0;
        int rows = matrix.size(), columns = matrix[0].size();
        vector<vector<int>> dp(rows, vector<int>(columns, 0));
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        // 如果i和j至少一个为0，以(i,j)为右下角的最大正方形边长只能是1
                        dp[i][j] = 1;
                    }
                    else {
                        // dp(i,j)的值由其上方、左方和左上方的三个相邻位置的dp值决定。当前位置的元素值等于三个相邻位置的元素中的最小值加1
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    }
                    maxSide = max(maxSide, dp[i][j]);
                }
            }
        }

        int square = maxSide * maxSide;
        return square;
    }
};
```





## 分治法

### 241 为运算表达式设计优先级

#### 方法1：分治、递归

对于一个形如 x op y（op 为运算符，x 和 y 为数） 的算式而言，它的结果组合取决于 x 和 y 的结果组合数，而 x 和 y 又可以写成形如 x op y 的算式。

因此，该问题的子问题就是 x op y 中的 x 和 y：以运算符分隔的左右两侧算式解。

```cpp
class Solution {
public:
	vector<int> diffWaysToCompute(string expression) {
		int n = expression.length();
		vector<int> ways;
		for (int i = 0; i < n; ++i) {
			char c = expression[i];
			if (c == '+' || c == '-' || c == '*') {
				//1、分解：遇到运算符，计算左右两侧的结果集
				//2、解决：diffWaysTocompute递归函数求出子问题的解
				vector<int> left = diffWaysToCompute(expression.substr(0, i));
				vector<int> right = diffWaysToCompute(expression.substr(i + 1));
				//3、合并：根据运算符合并子问题的解
				for (int l : left) {
					for (int r : right) {
						switch (c) {
						case '-':ways.push_back(l - r); break;
						case '+':ways.push_back(l + r); break;
						case '*':ways.push_back(l * r); break;
						}
					}
				}
			}

		}
		if (ways.empty()) {
			ways.push_back(stoi(expression));
		}
		return ways;
	}
};
```







## 数学

### 204 计数质数

#### 方法1：埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）

1、初始化长度 O(n)O(n) 的标记数组，表示这个数组是否为质数。数组初始化所有的数都是质数.

2、从 2 开始将当前数字的倍数全都标记为合数。标记到sqrt(n)时停止即可。

```cpp
class Solution {
public:
	int countPrimes(int n) {
		vector<bool> primes(n, true);
		// 从2开始枚举到sqrt(n)
		for (int i = 2; i * i < n; ++i) {
			// 如果当前是质数
			if (primes[i]) {
				// 就把从i*i开始，i的所有倍数都设置为false
				// 因为如果x>2，2*x被2过滤掉了，3*x被3过滤掉了，...，最小未被过滤的是x^2
				for (int j = i * i; j < n; j += i) {
					primes[i] = false;
				}
			}
		}
		int count = 0;
		for (int i = 2; i < n; ++i) {
			if (primes[i]) {
				++count;
			}
		}
		return count;
	}
};
```

### 504 七进制数

#### 方法1：

```cpp
class Solution {
public:
	string convertToBase7(int num) {
		string ans = "";
		if (num == 0) {
			return "0";
		}
		int flag = num < 0 ? 1 : 0;
		if (flag) {
			num = -num;
		}
		while (num) {
			int tmp = num % 7;
            //to_string结果转为字符串
			ans = to_string(tmp) + ans;
			num = num / 7;
		}
		return flag ? "-" + ans : ans;
	}
};
```



### 136 只出现一次的数字

#### 方法1：异或运算

```
1.任何数和 0做异或运算，结果仍然是原来的数，即 a⊕0=a。
2.任何数和其自身做异或运算，结果是0，即 a⊕a=0。
3.异或运算满足交换律和结合律，即 
a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。

假设数组中有2m+1个数，其中有m个数各出现两次，一个数出现一次。令a1、a2、...、am为出现两次的m个数，am+1为出现一个的数
```

![1678694733857](/assets/1678694733857.png)

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret=0;
        for(auto e:nums) ret^=e;
        return ret;
    }
};
```



### 338 比特位计数

##### 方法1：

![1678697389239](/assets/1678697389239.png)

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> result(n + 1);
        result[0] = 0;
        for (int i = 1; i <= n; i++) {
            if (i % 2 == 1) {
                result[i] = result[i - 1] + 1;
            }
            else {
                result[i] = result[i / 2];
            }
        }
        return result;
    }
};
```



### 461 汉明距离

#### 方法1：移位实现位计数

![fig1](/assets/1.png)

计算x和y之间的汉明距离，可以先计算x异或y，然后统计结果中等于1的位数。

![fig2](/assets/2-1678697823872.png)

具体地，记 s=x⊕y，我们可以不断地检查 s 的最低位，如果最低位为 1，那么令计数器加一，然后我们令 s 整体右移一位，这样 s 的最低位将被舍去，原本的次低位就变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量。

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int s = x ^ y;
        int ret = 0;
        while (s) {
            // s & 1可以把最低位取出来
            ret += s & 1;
            // s右移一位，s=s>>1;
            s >>= 1;
        }
        return ret;
    }
};
```



### 31 下一个排列

![1678795858580](/assets/1678795858580.png)

![1678795915195](/assets/1678795915195.png)

```
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if (nums.size() <= 1) return;
        int i = nums.size() - 2, j = nums.size() - 1, k = nums.size() - 1;
        while (i >= 0 && nums[i] >= nums[j]) {
            i--;
            j--;
        }

        if (i >= 0) {
            while (k>=j && nums[i] >= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + j, nums.end());
    }
};
```



### 9 回文数

通过取整和取余操作获取整数中对应的数字进行比较。

举个例子：1221 这个数字。

- 通过计算 1221 / 1000， 得首位1
- 通过计算 1221 % 10， 可得末位 1
- 进行比较
- 再将 22 取出来继续比较

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0) return false;
        int div=1;
        while(x/div>=10) div*=10;
        while(x>0){
            int left=x/div;
            int right=x%10;
            if(left!=right) return false;
            // 去掉头尾两位的数字
            x=(x%div)/10;
            div/=100;
        }
        return true;
    }
};
```



## 其他

### 48 旋转图像

#### 方法1：原地旋转

需要一个一个去推

![1678801241765](/assets/1678801241765.png)

![1678801266615](/assets/1678801266615.png)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < (n + 1) / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }

    }
};
```



### 75 颜色分类

#### 方法1：单指针

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        // 用ptr表示头部的范围
        // 从0到ptr-1都属于头部
        int ptr = 0;
        // 把0都交换到头部的范围
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
		// 从0后面开始，把1都交换到头部的范围
        for (int i = ptr; i < n; i++) {
            if (nums[i] == 1) {
                swap(nums[i], nums[ptr]);
                ++ptr;
            }
        }
    }
};
```



### 152 乘积最大子序列

#### 方法1：

![1678933870074](/assets/1678933870074.png)

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int resMax=INT_MIN, imax = 1, imin = 1;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] < 0) {
                int tmp = imax;
                imax = imin;
                imin = tmp;
            }

            imax = max(imax * nums[i], nums[i]);
            imin = min(imin * nums[i], nums[i]);
            resMax = max(resMax, imax);
        }
        return resMax;
    }
};
```



### 560 和为K的子数组

#### 方法1：前缀表+哈希表优化

![1678938245355](/assets/1678938245355.png)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto x : nums) {
            pre += x;
            if (mp.find(pre - k) != mp.end()) {
                count += mp[pre - k];
            }
            mp[pre]++;
        }
        return count;
    }
};
```



### 560 和为K的子数组

#### 方法1：哈希表+前缀和

![1678955718128](/assets/1678955718128.png)

![1678955730862](/assets/1678955730862.png)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp;
        mp[0] = 1;
        int count = 0, pre = 0;
        for (auto& x : nums) {
            // 遍历nums数组，求每一项的前缀和
            pre += x;
            // 边存边查看mp，如果mp中存在key为[当前前缀和-k],
            // 说明之前出现过前缀和满足：prefixSum[j]-prefixSum[i-1]=k
            if (mp[pre-k]>0) {
                // 将这样前缀和的个数累加给count
                count += mp[pre - k];
            }
            // 统计该前缀和出现的次数，以键值对存入哈希表mp
            mp[pre]++;
        }
        return count;
    }
};
```



### 238 除自身以外数组的乘积

#### 方法1：

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();

        // L 和 R 分别表示左右两侧的乘积列表
        vector<int> L(length, 0), R(length, 0);

        vector<int> answer(length);

        // L[i] 为索引 i 左侧所有元素的乘积
        // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1
        L[0] = 1;
        for (int i = 1; i < length; i++) {
            L[i] = nums[i - 1] * L[i - 1];
        }

        // R[i] 为索引 i 右侧所有元素的乘积
        // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1
        R[length - 1] = 1;
        for (int i = length - 2; i >= 0; i--) {
            R[i] = nums[i + 1] * R[i + 1];
        }

        // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积
        for (int i = 0; i < length; i++) {
            answer[i] = L[i] * R[i];
        }
        return answer;
    }
};

```

