---
title: 剑指offer
date: 2023-08-11 12:48:17
permalink: /pages/af5f18/
categories:
  - 工作
  - 其他-刷题
tags:
  - 
author: 
  name: smileatl
  link: https://github.com/smileatl
---
![1669629383585](/assets/1669629383585.png)

## 数据结构

​        数组和字符串是两种最基本的数据结构，它们用连续内存分别存储数字和字符。
​		链表和树是面试中出现频率最高的数据结构。由于操作树需要操作大量的指针，应聘者在解决相关问题的时候一定要留意鲁棒性，否则容易出现程序崩溃的问题。
​		栈是一个与递归紧密相关的数据结构，同样队列也与广度优先遍历算法紧密相关，深刻理解这两种数据结
构能帮助我们解决很多算法问题。

### 数组

​		为了解决数组空间效率不高的问题，人们又设计实现了多种动态数组，比如C++的STL 中的 vector。为了避免浪费，我们先为数组开辟较小的空间，然后往数组中添加数据。当数据的数目超过数组的容量时，我们再重新分配一块更大的空间(STL的 vector 每次扩充容量时，新的容量都是前一次的两倍)，把之前的数据复制到新的数组中，再把之前的内存释放，这样就能减少内存的浪费。==但我们也注意到每一次扩充数组容量时都有大量的额外操作，这对时间性能有负面影响，因此使用动态数组时要尽量减少改变数组容量大小的次数。==

​		当我们声明一个数组时，数组的名字也是一个指针，该指针指向数组的第一个元素。C/C++没有记录数组的大小，因此在用指针访问数组中的元素是，要确保没有超出数组的边界。

![1669633798021](/assets/1669633798021.png)

```
输出“20,4,4”
data1是一个数组，sizeof(data1)是求数组的大小，数组包含5个整数，每个整数4字节，一共20字节
data2声明为指针，32位系统上，对任意指针求sizeof，得到的结果都是4
C/C++中，数组最为函数的参数进行传递时，数组会自动退化成同类型的指针，所以size3也为4
```

#### 3 、数组中重复的数字

##### 方法一：哈希表

```cpp
class Solution {
public:
	int findRepeatNumber(vector<int>& nums) {
		//哈希表记录数组中的各个数字
		unordered_map<int, bool> map;
		//遍历数组nums中的每个数字num
		for (auto num : nums) {
			//当num在哈希表中，说明重复，直接返回num
			if (map[num]) {
				return num;
			}
			//将num添加至哈希表中
			map[num] = true;
		}
		return -1;
	}
};
```

##### 第2次：

```cpp
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        unordered_set<int> s;
        for(int i=0;i<nums.size();i++){
            if(s.count(nums[i])==0){
                // cout<<nums[i];
                s.insert(nums[i]);
                // cout<<*s.begin();
            }
            else{
                // cout<<nums[i];
                return nums[i];
            }
            
        }
        return -1;
    }
};
```



#### 4、二维数组中的查找

##### 方法一：标志数

从左下角开始找

```cpp
class Solution {
public:
	bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
		int i = matrix.size() - 1;
		int j = 0;
		while (i >= 0 && j <matrix[0].size()) {
			//如果当前值大于target，则target一定在当前值的行上方，--i消去当前行
			if (matrix[i][j] > target) {
				--i;
			}
			//当前值小于target，则target一定在当前值的列右方，++j消去当前列
			else if (matrix[i][j] < target) {
				++j;
			}
			else {
				return true;
			}
		}
		return false;
	}
};
```

### 字符串

#### 5、替换空格

##### 方法一：原地修改

- 初始化：空格数量 count ，字符串 s 的长度 len ；
- 统计空格数量：遍历 s ，遇空格则 count++ ；
- 修改 s 长度：添加完 "%20" 后的字符串长度应为 len + 2 * count ；
- 倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i = j 时跳出（代表左方已没有空格，无需继续遍历）；
  1）当 s[i] 不为空格时：执行 s[j] = s[i] ；
  2）当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 "%20" ；由于修改了 3 个元素，因此需要 j -= 2 ；
- 返回值：已修改的字符串 s ；

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0, len = s.size();
        // 统计空格数量
        for (char c : s) {
            if (c == ' ') count++;
        }
        // 修改 s 长度
        s.resize(len + 2 * count);
        // 倒序遍历修改
        for (int i = len - 1, j = s.size() - 1; i < j; i--, j--) {
            if (s[i] != ' ')
                s[j] = s[i];
            else {
                s[j - 2] = '%';
                s[j - 1] = '2';
                s[j] = '0';
                j -= 2;
            }
        }
        return s;
    }
};
```

#### 58、左旋转字符串

##### 方法1：三次反转

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
		reverse(s.begin(), s.begin() + n); //反转区间为前n的子串
		reverse(s.begin() + n, s.end()); //反转区间为n到末尾的子串
		reverse(s.begin(), s.end()); //反转整个字符串
		return s;
    }
};
```



### 链表

#### 6、从尾到头打印链表

##### 方法一：栈

后进先出，可以选择栈作为数据结构

```cpp
class Solution {
public:
	vector<int> reversePrint(ListNode* head) {
		ListNode* temp = head;
		stack<int> s;
		vector<int> v;
		while (temp != nullptr) {
			s.push(temp->val);
			temp = temp->next;
		}

		while (!s.empty()) {
			v.push_back(s.top());
			s.pop();
		}
		return v;
	}
};
```

#### 24、反转链表





##### 方法一：迭代

```cpp
class Solution {
public:
	ListNode* reverseList(ListNode* head) {
		ListNode* curr = head;
		ListNode* prev = nullptr;

		while (curr) {
			ListNode* temp = curr->next;
			curr->next = prev;
			prev = curr;
			curr = temp;
		}
		return prev;
	}
};
```

#### 24、合并两个排序的链表

##### 方法一：递归

```cpp
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		if (l1 == nullptr) {
			return l2;
		}
		else if (l2 == nullptr) {
			return l1;
		}
		
		if (l1->val < l2->val) {
			l1->next = mergeTwoLists(l1->next, l2);
			return l1;
		}
		else {
			l2->next = mergeTwoLists(l1, l2->next);
			return l2;
		}
	}
};
```

#### 52、两个链表的第一个公共结点

##### 方法一：双指针

```cpp
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
		ListNode* curA = headA;
		ListNode* curB = headB;
		while (curA != curB) {
			curA = curA ? curA->next : headB;
			curB = curB ? curB->next : headA;
		}
		return curA;
    }
};
```

#### II 22、链表中环的入口结点

##### 方法一：哈希表

```cpp
class Solution {
public:
	ListNode* detectCycle(ListNode* head) {
		unordered_set<ListNode*> uset;
		ListNode* cur = head;
		while (cur != nullptr) {
            //一旦遇到了此前遍历过得结点，说明有环，并返回该结点
			if (uset.count(cur)) {
				return cur;
			}
			uset.insert(cur);
			cur = cur->next;
		}
		return nullptr;
	}
};
```

#### 22、链表中倒数第k个结点

##### 方法一：双指针

1. 后一个指针先走k步
2. 然后两个指针一起走，直到后一个指针为空
3. 返回前一个指针

```cpp
class Solution {
public:
	ListNode* getKthFromEnd(ListNode* head, int k) {
		ListNode* former = head, * latter = head;
		for (int i = 1; i <= k; ++i) {
			latter = latter->next;
		}

		while (latter != nullptr) {
			latter = latter->next;
			former = former->next;
		}
		return former;
	}
};
```



#### JZ22 链表中倒数最后k个结点

多了链表长度小于k，则返回一个长度为0的链表

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        // write code here
        ListNode* p1=pHead;
        ListNode* p2=pHead;
        for(int i=0;i<k;i++){
            if(p1!=nullptr){
                p1=p1->next;
            }
            else{
                return nullptr;
            }
        }
        while(p1!=nullptr){
            p1=p1->next;
            p2=p2->next;
        }
        return p2;
    }
};
```



#### 18、删除链表的结点

##### 方法一：两个指针

1. 特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。
2. 初始化： `pre = head` , `cur = head.next` 。
3. 定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。
   1. 保存当前节点索引，即 `pre = cur` 。
   2. 遍历下一节点，即 `cur = cur.next` 。
4. 删除节点： 若 `cur` 指向某节点，则执行 `pre.next = cur.next` ；若 `cur` 指向 `null`，代表链表中不包含值为 `val` 的节点。
5. 返回值： 返回链表头部节点 `head` 即可



```cpp
class Solution {
public:
	ListNode* deleteNode(ListNode* head, int val) {
		if (head->val == val) {
			return head->next;
		}
		ListNode* cur = head, * pre = head;
		while (cur->next != nullptr && cur->val != val) {
			pre = cur;
			cur = cur->next;
		}
		if (cur != nullptr) {
			pre->next = cur->next;
		}
		return head;
	}
};
```

##### 第2次

```cpp
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* dummy=new ListNode();
        dummy->next=head;
        ListNode* cur=head;
        ListNode* pre=dummy;

        while(cur!=nullptr){
            if(cur->val==val){
                pre->next=cur->next;
                break;
            }
            pre=pre->next;
            cur=cur->next;
        }

        return dummy->next;
    }
};
```



### 哈希表

#### 剑指 Offer II 004. 只出现一次的数字

##### 方法1：很慢的哈希表

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> umap;
        for(int i=0;i<nums.size();i++){
            umap[nums[i]]++;
        }
        for(auto num:nums){
            if(umap[num]==1){
                return num;
            }
        }
        return -1;
    }
};
```



#### 35. 复杂链表的复制

##### 方法1：哈希表

本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建 

![1688442826851](/assets/1688442826851.png)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr) return nullptr;
        // 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        unordered_map<Node*, Node*> map;
        Node* cur=head;
        while(cur!=nullptr){
            map[cur]=new Node(cur->val);
            cur=cur->next;
        }
        cur=head;
        // 构建新节点的 next 和 random 指向
        while(cur!=nullptr){
            map[cur]->next=map[cur->next];
            map[cur]->random=map[cur->random];
            cur=cur->next;
        }
        // 返回新链表的头节点
        return map[head];
    }
};
```



### 栈与队列

#### 59 - I. 滑动窗口的最大值

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> result;
        int len =nums.size();
        if(len==0 || k==0 || k>len) return result;
        //deque 中存储的是num的下标
        deque<int> que;
        for(int i=0;i<len;i++){
            //当前值比队列从后往前的大，成为下一个待选值
            while(!que.empty() && nums[que.back()]<nums[i]){
                que.pop_back();
            }
            //最大值已不在窗口中
            while(!que.empty() && i-que.front()+1 > k){
                que.pop_front();
            }
            que.push_back(i);

            //当滑动窗口首地址i大于等于size时才开始写入窗口最大值
            if(i+1>=k){
                result.push_back(nums[que.front()]);
            }
        }
        return result;

    }
};
```



#### 40. 最小的k个数

##### 方法1：优先队列

```cpp
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        priority_queue<int, vector<int>, greater<int>> pq;
        for(auto a:arr){
            pq.push(a);
        }
        vector<int> result;
        while(k--){
            result.push_back(pq.top());
            pq.pop();
        }
        return result;
    }
};
```



#### 41. 数据流中的中位数

##### 方法1：优先队列

![1688357079302](/assets/1688357079302.png)

- 方法一解释有些错误
- 题解中给的解释是“用两个优先队列 queMax 和 queMin 分别记录大于中位数的数和小于等于中位数的数”，但是实际运行过程中会出现违背这个定义的情况，比如当中位数重复时，会出现相同数值存在于queMax的情况
- 个人认为更好的解释是维护两个平衡优先队列，queMax保存了数据流中较大的那一半元素，queMin保存了数据流中较小的那一半元素，同时平衡的意思是两个队列的大小之差小于等于1，且只能queMin比queMax大1

```cpp
class MedianFinder {
public:

    // 大的在前
    priority_queue<int, vector<int>, less<int>> queMin;
    // 小的在前
    priority_queue<int, vector<int>, greater<int>> queMax;

    /** initialize your data structure here. */
    MedianFinder() {

    }
    
    void addNum(int num) {
        if(queMin.empty() || num<=queMin.top()){
            queMin.push(num);
            if(queMax.size()+1<queMin.size()){
                queMax.push(queMin.top());
                queMin.pop();
            }
        }
        else{
            queMax.push(num);
            if(queMax.size()>queMin.size()){
                queMin.push(queMax.top());
                queMax.pop();
            }
        }
    }
    
    double findMedian() {
        if (queMin.size() > queMax.size()) {
            return queMin.top();
        }
        return (queMin.top() + queMax.top()) / 2.0;
    }

    
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



#### 31. 栈的压入、弹出序列

每次都用栈顶元素跟poped对比，相等就弹出

最后判断栈stack是不是空的

```cpp
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int i=0;
        for(auto num:pushed){
            st.push(num); // num 入栈
            // 循环判断与出栈
            while(!st.empty() && st.top()==popped[i]){
                st.pop();
                i++;
            }
        }
        return st.empty();
    }
};
```



#### 30. 包含min函数的栈

```cpp
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> x_stack;
    stack<int> min_stack;

    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        //注意当前类中也有一个min函数，
        //所以我们需要明确此时的min函数是哪个函数
        x_stack.push(x);
        min_stack.push(std::min(min_stack.top(), x));
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int min() {
        return min_stack.top();    
    }   
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(x);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->min();
 */
```

#### 7、用两个栈实现队列

```cpp
class CQueue {
public:
    stack<int> st1;
    stack<int> st2;
    int size=0;


    CQueue() {

    }
    
    void appendTail(int value) {
        st1.push(value);
        size++;
    }
    
    int deleteHead() {
        if(size==0) return -1;

        if(st2.empty()){
            while(!st1.empty()){
                st2.push(st1.top());
                st1.pop();
            }
        }

        size--;
        int value = st2.top();
        st2.pop();
        return value;
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```



### 树

#### 55、二叉树的深度

##### 方法一：递归

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //当root为空，说明已经越过叶子结点，返回深度0
        if (!root) {
            return 0;
        }
        //本质上是后序遍历
        //递归计算右子树和左子树的深度
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

#### 27、二叉树的镜像

##### 方法一：写得很差的递归

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if (root == nullptr) {
            return nullptr;
        }
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        if (root->left) {
            mirrorTree(root->left);
        }
        if (root->right) {
            mirrorTree(root->right);
        }
        return root;
    }
};
```

##### 第2次：递归

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(root==nullptr){
            return nullptr;
        }
        TreeNode* left=mirrorTree(root->left);
        TreeNode* right=mirrorTree(root->right);

        root->left=right;
        root->right=left;

        return root;
    }
};
```

##### 第3次：

```cpp
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if (root == nullptr) return nullptr;
        TreeNode* tmp = root->left;
        root->left = mirrorTree(root->right);
        root->right = mirrorTree(tmp);
        return root;
    }
};
```



#### 32、从上到下打印二叉树

##### 方法一：层次遍历

用栈来实现层次遍历（做了几次之后，已经比较简单了）

```cpp
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        queue<TreeNode*> q;
        vector<int> v;
        if (root == nullptr) {
            return v;
        }
        q.push(root);
        while (!q.empty()) {
            v.push_back(q.front()->val);
            if (q.front()->left != nullptr) {
                q.push(q.front()->left);
            }
            if (q.front()->right != nullptr) {
                q.push(q.front()->right);
            }
            q.pop();
        }
        return v;
    }
};
```

#### 68、二叉搜索树的最近公共祖先

##### 方法一：递归

最近公共祖先的定义： 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。

根据以上定义，若 root 是 p,q 的 **最近公共祖先** ，则只可能为以下情况之一：

1. p 和 q 在 root 的子树中，且分列 root 的 **异侧**（即分别在左、右子树中）；
2. p = root，且 q 在 root 子树中；
3. q = root，且 p 在 root 的左或右子树中；



本题给定了两个重要条件：① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：

1. 若 root.val < p.val ，则 p 在 root 右子树 中；
2. 若 root.val > p.val ，则 p 在 root 左子树 中；
3. 若 root.val = p.val ，则 p 和 root 指向 同一节点 。

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //终止条件：不需要，因为官方给了均存在与树中的条件
        //递归操作
        //第一种情况：
        if (root->val < p->val && root->val < q->val) {//看看是不是都是左儿子的后代
            return lowestCommonAncestor(root->right, p, q);//是的话就丢给左儿子去认后代（继续递归）
        }
        //第二种情况：
        if (root->val > p->val && root->val > q->val) {//不是左儿子的后代，看看是不是都是右儿子的后代
            return lowestCommonAncestor(root->left, p, q);//是的话就丢给右儿子去认后代（继续递归）
        }
        //第三种情况：
        //左儿子和右儿子都只认识一个，当前root就是最近的祖先，因为root本来就是p、q的公共的祖先
        //第三种才是题目需要找到的解，所以返回
        return root;
    }
};
```

#### 28、对称的二叉树

##### 方法1：递归

做过的题不要再忘了

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root) {
            return helper(root->left, root->right);
        }
        else {
            return true;
        }
    }

    bool helper(TreeNode* p, TreeNode* q) {
        if (!p && !q) {
            return true;
        }
        if (!p || !q) {
            return false;
        }
        if(p->val!=q->val){
            return false;
        }
        return helper(p->left, q->right) && helper(p->right, q->left);
    }

};
```

#### 54、二叉搜索树的第k大结点

##### 方法1：中序遍历（迭代法）

```cpp
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        vector<int> v;
        stack<TreeNode*> s;
        while (root || !s.empty()) {
            while (root) {
                s.push(root);
                //找到最最左的结点
                root = root->left;
            }
            root = s.top();
            s.pop();
            v.emplace_back(root->val);
            //取右子树
            root = root->right;
        }
        //取第k个大的数
        return v[v.size() - k];
    }
};
```

#### 7、重建二叉树

##### 方法1：分支算法

![1671100569928](/assets/1671100569928.png)

主要是左右子树边界条件的判断比较难懂

```cpp
class Solution {
public:
	vector<int> preorder;
	unordered_map<int, int> dic;

	TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		this->preorder = preorder;
		//建立哈希表dic，键：结点的值，值：在中序遍历中出现的位置
		for (int i = 0; i < inorder.size(); ++i) {
			dic[inorder[i]] = i;
		}
		return helper(0, 0, inorder.size() - 1);
	}
	//输入参数
	//root:根结点在前序遍历的索引
	//left:子树在中序遍历的左边界
	//right:子树在中序遍历的右边界
	TreeNode* helper(int root, int left, int right) {
		//当left>right，代表已经越过叶节点，此时返回null
		if (left > right) return nullptr;
		//1、建立根结点node：结点值为preorder[root]
		TreeNode* node = new TreeNode(preorder[root]);
		//2、划分左右子树：查找根结点在中序遍历inorder中的索引i
		int i = dic[preorder[root]];
		//左子树的根结点索引：root+1
		node->left = helper(root + 1, left, i - 1);
		//右子树的根结点索引：root + i - left + 1（根结点索引+左子树长度+1）
		node->right = helper(root + i - left + 1, i + 1, right);
		//返回值：回溯返回node，作为上一层递归中根结点的左/右子结点
		return node;
	}
};
```

##### 方法2：同上，复习

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int, int> umap;
        for(int i=0;i<inorder.size();i++){
            umap[inorder[i]]=i;
        }
        return helper(preorder, umap, 0,0, inorder.size()-1);
    }

    TreeNode* helper(vector<int>& preorder, unordered_map<int, int>& umap, int root, int left, int right){
        if(left>right) return nullptr;
        TreeNode* node=new TreeNode(preorder[root]);
        int i=umap[preorder[root]];
        node->left=helper(preorder, umap, root+1, left, i-1);
        node->right=helper(preorder, umap, root+1+i-left, i+1, right);
        return node;
    }    
};
```

##### 第3次

```cpp
class Solution {
public:
    unordered_map<int, int> umap;

    TreeNode* helper(vector<int>& preorder, vector<int>& inorder, int preorderleft, int preorderright, int inorderleft, int inorderright){
        if(preorderleft>preorderright) return nullptr;
        int preorderroot=preorder[preorderleft];
        int inorderroot=umap[preorderroot];
        TreeNode* root=new TreeNode(preorderroot);
        int size_of_left=inorderroot-inorderleft;
        root->left=helper(preorder, inorder, preorderleft+1, preorderleft+size_of_left,inorderleft, inorderroot-1);
        root->right=helper(preorder, inorder, preorderleft+size_of_left+1, preorderright, inorderroot+1, inorderright);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int m=preorder.size();
        for(int i=0;i<m;i++){
            umap[inorder[i]]=i;
        }

        TreeNode* root=helper(preorder, inorder, 0, m-1, 0, m-1);
        return root;
    }
};
```



#### 33、二叉搜索树的后序遍历序列

##### 方法1：递归

```CPP
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        if(postorder.empty()) return true;
        return helper(postorder, 0, postorder.size()-1);
    }

    bool helper(vector<int>& postorder, int start, int end){
        if(start>=end){
            return true;
        }
        int left=start;
        // 一直到左子树为止，左子树所有都要小于根
        while(left<end && postorder[left]<postorder[end]){
            ++left;
        }
        // 这里验证右子树，右子树所有都要大于根
        for(int i=left;i<end;i++){
            if(postorder[i]<postorder[end]){
                return false;
            }
        }
        return helper(postorder, start, left-1) && helper(postorder, left, end-1);
    }
};
```



#### 34、二叉树中和为某一值的路径

##### 方法1：递归

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;

    void helper(TreeNode* root, int sum){
        if(root==nullptr){
            return;
        }
        path.push_back(root->val);
        if(root->left==nullptr && root->right ==nullptr && root->val==sum){
            result.push_back(path);
        }
        else{
            if(root->left!=nullptr){
                helper(root->left, sum-root->val);
            }
            if(root->right!=nullptr){
                helper(root->right, sum-root->val);
            }
        }
        // 到叶子节点才会pop
        path.pop_back();
        
    }

    vector<vector<int>> pathSum(TreeNode* root, int target) {
        helper(root, target);
        return result;
    }
};
```



#### 26、树的子结构

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* root1, TreeNode* root2){
        // p2为空，不管p1是不是空都是正确的
        if(root2==nullptr) return true; 
        // p1为空，p2不为空，一定是错误的
        if(root1==nullptr) return false;
        if(root1->val==root2->val){
            return helper(root1->left, root2->left) && helper(root1->right, root2->right);
        }
        else{
            return false;
        }
    }
    
    bool isSubStructure(TreeNode* A, TreeNode* B)
    {
        // 题目约定空树不是任意一个树的子结构
        // 所有只要一个为空了，直接返回false
        if(A==nullptr || B==nullptr) return false;
        return isSubStructure(A->left, B) || isSubStructure(A->right, B) || helper(A, B);
    }
};
```



#### 32 - II. 从上到下打印二叉树 II

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root==nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()){
            vector<int> vec;
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```



#### 32 - III. 从上到下打印二叉树 III

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root==nullptr) return result;
        queue<TreeNode*> que;
        que.push(root);
        bool flag=false;
        while(!que.empty()){
            vector<int> vec;
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                vec.push_back(node->val);
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            flag=!flag;
            if(flag){
                result.push_back(vec);
            }
            else{
                result.push_back(vector<int>(vec.rbegin(), vec.rend()));
            }
        }
        return result;
    }
};
```



####  37. 序列化二叉树

```cpp
class Codec {

public:
    // i需要传入引用，因为要更改它的参数值
    TreeNode* helper(string& data, int& i){
        if(data[i]=='#'){
            ++i;
            return nullptr;
        }
        int num=0, negativeFlag=1;
        if(data[i]=='-'){
            negativeFlag=-1;
            ++i;
        }
        while(data[i]!='!'){
            num = num * 10 + data[i] - '0';
            ++i;
        }
        if(negativeFlag==-1){
            num=-num;
        }

        TreeNode* root=new TreeNode(num);
        // i++移位下一个数
        root->left=helper(data, ++i);
        root->right=helper(data, ++i);
        return root;
    }


	// Encodes a tree to a single string.
	string serialize(TreeNode* root) {
		if(root==nullptr) return "#!";
        string str=to_string(root->val)+'!';
        str+=serialize(root->left);
        str+=serialize(root->right);
        return str;
	}

	// Decodes your encoded data to tree.
	TreeNode* deserialize(string data) {
		int i=0;
        return helper(data, i);
	}
};
```



#### 55 - II. 平衡二叉树

##### 方法1：后序遍历+剪枝（从底至顶）

![1688392871690](/assets/1688392871690.png)

```cpp
class Solution {
public:
    int recur(TreeNode* node){
        if(node==nullptr) return 0;
        int left=recur(node->left);
        if(left==-1) return -1;
        int right=recur(node->right);
        if(right==-1) return -1;
        return abs(left-right)<2?max(left, right)+1:-1;
    }

    bool isBalanced(TreeNode* root) {
        return recur(root)!=-1;
    }
};
```



## 算法

### 多指针

#### 49. 丑数

丑数（Ugly Number）是指只包含质因子2、3和5的正整数。换句话说，如果一个正整数只能被2、3和5整除，而不能被其他质数整除，那么它就是一个丑数。

丑数序列的前几个数是：1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, ...

可以观察到，丑数可以通过将较小的丑数乘以2、3或5来获得。例如，2是第一个丑数，将它乘以2得到4，将4乘以2得到8，以此类推。同样地，将2乘以3得到6，将2乘以5得到10，以及将3乘以3得到9等。

```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n<7) return n;
        vector<int> result(n,0);
        result[0]=1;
        int twoIndex=0, threeIndex=0, fiveIndex=0;
        for(int i=1;i<n;i++){
            // cout<<i<<endl;
            int minNum=min(min(result[twoIndex]*2, result[threeIndex]*3), result[fiveIndex]*5);
            if(minNum==result[twoIndex]*2) twoIndex++;
            if(minNum==result[threeIndex]*3) threeIndex++;
            if(minNum==result[fiveIndex]*5) fiveIndex++;
            result[i]=minNum;
        }
        return result[n-1];
    }
};
```



#### 21. 调整数组顺序使奇数位于偶数前面

##### 方法1：双指针

![1688461214229](/assets/1688461214229.png)

![1688461193460](/assets/1688461193460.png)

```cpp
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int i=0, j=nums.size()-1;
        while(i<j){
            while(i<j && nums[i]%2==1) i++;
            while(i<j && nums[j]%2==0) j--;
            swap(nums[i], nums[j]);
        }
        return nums;
    }
};
```





#### 48. 最长不含重复字符的子字符串

使用滑动窗口算法来解决问题。我们使用两个指针 `left` 和 `right` 表示滑动窗口的左右边界。我们还使用一个哈希集合 `charSet` 来存储当前窗口中的字符集合。

我们从左到右遍历字符串，不断移动右指针。对于每个字符，我们检查它是否已经在当前窗口中存在。如果存在，我们移动左指针，并从字符集合中移除对应的字符，直到窗口中不再包含重复的字符。

然后，我们将当前字符加入窗口，并更新最长子字符串的长度。最后，我们将右指针向右移动，继续遍历下一个字符。

通过遍历整个字符串，我们可以找到最长的不包含重复字符的子字符串的长度。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.length();
        int left = 0, right = 0; // 滑动窗口的左右指针
        int maxLength = 0; // 最长子字符串的长度
        unordered_set<char> charSet; // 用于存储当前窗口中的字符集合

        while (right < n) {
            // 如果当前字符已经在窗口中存在，则移动左指针，并从字符集合中移除对应的字符
            while (charSet.count(s[right]) > 0) {
                charSet.erase(s[left]);
                left++;
            }

            // 将当前字符加入窗口，并更新最长子字符串的长度
            charSet.insert(s[right]);
            maxLength = max(maxLength, right - left + 1);

            right++; // 右指针向右移动
        }

        return maxLength;
    }
};
```



### 递归

#### 62. 圆圈中最后剩下的数字

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        if(n<=0 || m<0) return -1;
        int res=0;
        for(int i=2;i<=n;i++){
            res=(res+m)%i;
        }
        return res;
    }
};                                                                            
```



#### 36. 二叉搜索树与双向链表

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node *head, *pre;
    void dfs(Node* cur){
        if(cur==nullptr) return;
        dfs(cur->left);

        //pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur,当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点
        if(pre==nullptr) head=cur;
        //反之，pre!=null时，cur左侧存在节点pre，需要进行pre.right=cur的操作。
        else pre->right=cur;
        
        //pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的。
        cur->left=pre;
        
		//pre指向当前的cur
        pre=cur;
        //全部迭代完成后，pre指向双向链表中的尾节点
        dfs(cur->right);
    }

    Node* treeToDoublyList(Node* root) {
        if(root==nullptr) return nullptr;
        dfs(root);

        //进行头节点和尾节点的相互指向，这两句的顺序也是可以颠倒的
        pre->right=head;
        head->left=pre;

        return head;
    }
};
```



### 回溯

#### 13. 机器人的运动范围

##### 方法1：借助标记法

不算回溯法

```cpp
class Solution {
public:
    bool canReach(int threshold, int x, int y){
        int sum=0;
        while(x>0){
            sum+=x%10;
            x/=10;
        }
        while(y>0){
            sum+=y%10;
            y/=10;
        }
        return sum<=threshold;
    }

    int helper(int threshold, int i, int m, int j, int n, vector<vector<bool>>& visit){
        if(i<0 || i>=m || j<0 || j>=n || canReach(threshold, i, j)==false ||visit[i][j]==true) return 0;
        visit[i][j]=true;

        return helper(threshold, i-1, m, j, n, visit)+
               helper(threshold, i+1, m, j, n, visit)+
               helper(threshold, i, m, j-1, n, visit)+
               helper(threshold, i, m, j+1, n, visit)+1;
    }

    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        return helper(k, 0, m, 0, n, visit);
    }
};
```



#### 12. 矩阵中的路径

##### 方法1：回溯

```cpp
class Solution {
public:
    /*参数说明  k 字符串索引初始为0即先判断字符串的第一位*/
    bool helper(vector<vector<char>>& board, int i, int m, int j, int n, int k, string word, vector<vector<bool>>& visit){
        if(i<0 || i>=m || j<0 || j>=n || board[i][j]!=word[k] || visit[i][j]==true) return false;
        // 已匹配完整
        if(k==word.size()-1) return true;
        // 标记访问过
        visit[i][j]=true;
        if(helper(board, i-1, m, j, n, k+1, word, visit ) || 
           helper(board, i+1, m, j, n, k+1, word, visit) || 
           helper(board, i, m, j-1, n, k+1, word, visit) ||
           helper(board, i, m, j+1, n, k+1, word, visit)){
               return true;
        }
        // 走到这，说明这一条路不通，还原，再试其他的路径
        visit[i][j]=false;
        return false;
    }

    bool exist(vector<vector<char>>& board, string word) {
        
        int m=board.size(), n=board[0].size();
        if (board.empty() || m < 1 || n < 1 || word.empty()) return false;
        vector<vector<bool>> visit(m, vector<bool>(n, false));
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(helper(board, i, m, j, n, 0, word, visit))
                {
                    return true;
                }
            }
        }
        return false;
    }
};
```



#### 38. 字符串的排列

DFS+回溯算法

时间和空间复杂度都不太好

```cpp
class Solution {
public:
    vector<string>  result;
    void PermutationCore(string &s,int begin,int end){
        if(begin == end){
            result.push_back(s);
            return ;
        }
        unordered_map<int,int> visited;
        for(int i = begin; i<= end; ++i){
            if(visited[s[i]] == 1) continue;
            swap(s[i],s[begin]);
            PermutationCore(s,begin+1,end);
            swap(s[i],s[begin]);
            visited[s[i]] =1;

        }

    }
    
    vector<string> permutation(string str) {
    if(str.size()==0) return vector<string>();
    
    PermutationCore(str,0,str.size()-1);
    sort(result.begin(),result.end());
	return  result;
    }
};
```



### 动态规划

#### 42、连续子数组的最大和

##### 方法一：动态规划

![1670384172513](/assets/1670384172513.png)

```cpp
class Solution {
public:
	int maxSubArray(vector<int>& nums) {
        //初始化最大值为nums第一个数
		int maxAns = nums[0];
		for (int i = 1; i < nums.size(); ++i) {
			nums[i] += max(nums[i - 1], 0);
			maxAns = max(maxAns, nums[i]);
		}
		return maxAns;	
	}
};
```

#### 42、斐波那契数列

##### 方法一：动态规划

```cpp
class Solution {
public:
	int fib(int n) {
		if (n <= 1) {
			return n;
		}
		int pre1 = 0, pre2 = 1;
		int cur;
		for (int i = 2; i <= n; ++i) {
            //题目有一个取模操作的要求
			cur = (pre1 + pre2) % 1000000007;
			pre1 = pre2;
			pre2 = cur;
		}
		return cur;
	}
};
```

##### 第2次：

```
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        vector<int> dp(n+1);
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            dp[i]=(dp[i-1]+dp[i-2])%1000000007;
        }

        return dp[n];
    }
};

class Solution {
public:
	int fib(int n) {
		if (n <= 1) return n;
		int dp[2];
        // 初始值
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i <= n; i++) {
            // 递推公式，状态转移方程
			int sum = dp[0] + dp[1];
			dp[0] = dp[1];
			dp[1] = sum;
		}
		return dp[1];
	}
};
```





#### 46、把数字翻译成字符串

##### 方法1：动态规划

![1670399702017](/assets/1670399702017.png)

```cpp
class Solution {
public:
	int translateNum(int num) {
		int a = 1, b = 1;
		int c = 1;
        //求余
		int x, y = num % 10;
		while (num != 0) {
            //取整
			num /= 10;
            //其实是从右往左的遍历
			x = num % 10;
			int tmp = 10 * x + y;
			c = (tmp >= 10 && tmp <= 25) ? a + b : b;
			a = b;
			b = c;
			y = x;
		}
		return c;
	}
};
```

#### 63、股票的最大利润

##### 方法1：动态规划

![1670401766459](/assets/1670401766459.png)

![1670401788166](/assets/1670401788166.png)

```cpp
class Solution {
public:
	int maxProfit(vector<int>& prices) {
		int cost = INT_MAX;
		int profit = 0;
		for (auto price:prices) {
			cost = min(cost, price);
			profit = max(profit, price - cost);
		}
		return profit;
	}
};
```

#### 47、礼物的最大值

##### 方法1：写的比较差的动态规划

![1670402613424](/assets/1670402613424.png)

```cpp
class Solution {
public:
	int maxValue(vector<vector<int>>& grid) {
		int m = grid.size();
		int n = grid[0].size();
		vector<vector<int>> dp(m, vector<int>(n, 0));
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < n; ++j) {
				if (i == 0 && j == 0) {
					dp[i][j] = grid[i][j];
				}
				else if (i == 0) {
					dp[i][j] = dp[i][j - 1] + grid[i][j];
				}
				else if (j == 0) {
					dp[i][j] = dp[i - 1][j] + grid[i][j];
				}
				else {
					dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
				}
			}
		}
		return dp[m - 1][n - 1];
	}
};
```

##### 方法2：优化一点空间复杂度的动态规划

```cpp
//牺牲内存，优化一点时间复杂度
//方法：多开一行一列的空间，省略边界条件的判断
class Solution {
public:
	int maxValue(vector<vector<int>>& grid) {
		int m = grid.size();
		int n = grid[0].size();
		vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
		for (int i = 1; i < m + 1; ++i) {
			for (int j = 1; j < n + 1; ++j) {
				dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i-1][j-1];
			}
		}
		return dp[m][n];
	}
};
```



解这题需要把题意仔细研究清楚，反正我试了好多次才明白的。

 首先，**考虑特殊情况**： 1. 两个字符串都为空，返回true  2.当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法 匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成 功的，比如第二个字符串是“aaaa”,由于‘’之前的元素可以出现0次， 所以有可能匹配成功） 之后就开始匹配第一个字符，这里有两种可能：**匹配成功或匹配失败**。

 但考虑到pattern 下一个字符可能是‘’， 这里我们分两种情况讨论：pattern下一个字符为‘’或 不为‘’： 1. pattern下一个字符不为‘’：这种情况比较简单，直接匹配当前字符。如果 匹配成功，继续匹配下一个；如果匹配失败，直接返回false。

 注意这里的 “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的 当前字符为‘.’,同时str的当前字符不为‘\0’。 2. pattern下一个字符为‘’时，稍微复杂一些，因为‘’可以代表0个或多个。

 这里把这些情况都考虑到： a>当‘’匹配0个字符时，str当前字符不变，pattern当前字符后移两位， 跳过这个‘’符号； b>当‘’匹配1个或多个时，str当前字符移向下一个，pattern当前字符 不变。

（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时， 由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a； 当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配） 之后再写代码就很简单了。



#### 10- II. 青蛙跳台阶问题

> 求多少种可能性的题目一般都有递推性质

![1688469486212](/assets/1688469486212.png)

```cpp
class Solution {
public:
    int numWays(int n) {
        if(n==0) return 1;
        if(n==1) return 1;
        vector<int> dp(n+1);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<n+1;i++){
            
            dp[i]=(dp[i-1]+dp[i-2])%1000000007;
        }
        return dp[n];
    }
};
```



### 二分查找

#### 53 - I. 在排序数组中查找数字 I

![1688394652404](/assets/1688394652404.png)

很巧妙地去查找右边界，target-1

```cpp
class Solution {
public:
    int helper(vector<int>& nums, int target){
        int i=0,j=nums.size()-1;
        
        while(i<=j){
            int mid=(i+j)/2;
            if(nums[mid]<=target) i=mid+1;
            else{
                j=mid-1;
            }
            
        }
        // 这是右边界
        return i;
    }

    int search(vector<int>& nums, int target) {
        return helper(nums, target)-helper(nums, target-1);
    }
};
```



#### 11. 旋转数组的最小数字



```cpp
class Solution {
public:
    int minArray(vector<int>& numbers) {
        int n=numbers.size();
        int l=0, r=n-1;
        while(l<r){
            int mid=l+(r-l)/2;
            if(numbers[mid]>numbers[r]){
                l=mid+1;
            }
            else if(numbers[mid]<numbers[r]){
                r=mid;
            }
            else{
                r--;
            }
        }
        return numbers[l];
        // return numbers[r]; r、l相等一样
    }
};
```



### 模拟

#### 20. 表示数值的字符串

```cpp
class Solution {
private:
    // 整数的格式可以用[+|-]B表示, 其中B为无符号整数
    bool scanInteger(const string s, int& index){

        if(s[index] == '+' || s[index] == '-')
            ++index;

        return scanUnsignedInteger(s, index);
    }
    
    bool scanUnsignedInteger(const string s, int& index){

        int befor = index;
        while(index != s.size() && s[index] >= '0' && s[index] <= '9')
            index ++;

        return index > befor;
    }
public:
    // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，
    // 其中A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数
    bool isNumber(string s) {

        if(s.size() == 0)
            return false;
        int index = 0;

        //字符串开始有空格，可以返回true
        while(s[index] == ' ')  //书中代码没有该项测试
            ++index;

        bool numeric = scanInteger(s, index);

        // 如果出现'.'，接下来是数字的小数部分
        if(s[index] == '.'){

            ++index;

            // 下面一行代码用||的原因：
            // 1. 小数可以没有整数部分，例如.123等于0.123；
            // 2. 小数点后面可以没有数字，例如233.等于233.0；
            // 3. 当然小数点前面和后面可以有数字，例如233.666
            numeric = scanUnsignedInteger(s, index) || numeric;
        }

        // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分
        if(s[index] == 'e' || s[index] == 'E'){

            ++index;

            // 下面一行代码用&&的原因：
            // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；
            // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4
            numeric = numeric && scanInteger(s ,index);
        }

        //字符串结尾有空格，可以返回true
        while(s[index] == ' ')
            ++index;
        // cout << s.size() << " " << index;   //调试用

        return numeric && index == s.size();
    }
};
```

##### 第2次

```cpp
class Solution {
public:
    bool scanUnsignedInteger(string& s, int& index){
        int before=index;
        while(index!=s.size() && s[index]>='0' && s[index]<='9'){
            ++index;
        }
        return index>before;
    }

    bool scanInteger(string& s, int& index){
        if(s[index]=='+' || s[index]=='-'){
            ++index;
        }
        return scanUnsignedInteger(s, index);
    }

    bool isNumber(string s) {
        if(s.size()==0){
            return false;
        }
        int index=0;
        while(s[index]==' '){
            ++index;
        }

        bool numeric =  scanInteger(s, index);

        if(s[index]=='.'){
            ++index;
            numeric=scanUnsignedInteger(s, index) || numeric;
        }

        if(s[index]=='e' || s[index]=='E'){
            ++index;
            numeric=numeric && scanInteger(s, index);
        }

        while(s[index]==' '){
            ++index;
        }

        cout<<s.size() <<" "<<index;

        return numeric && index==s.size();
    }
};
```



#### 29、顺时针打印矩阵

##### 第1次

```cpp
class Solution {
public:
	vector<int> spiralOrder(vector<vector<int>>& matrix) {
        //当matrix为空时，直接返回空列表[]
		if (matrix.size() == NULL) {
			return vector<int>{};
		}
		int l=0, r=matrix[0].size()-1, t=0, b=matrix.size()-1;
		vector<int> res;
		while (true) {
            //根据边界打印
			for (int i = l; i <= r; ++i) {
				res.push_back(matrix[t][i]);
			}
            //边界向内收缩1，并判断是否打印完毕（边界是否相遇）
			if (++t > b) break;
			for (int i = t; i <= b; ++i) {
				res.push_back(matrix[i][r]);
			}
			if (--r < l) break;
			for (int i = r; i >= l; --i) {
				res.push_back(matrix[b][i]);
			}
			if (--b < t) break;
			for (int i = b; i >= t; --i) {
				res.push_back(matrix[i][l]);
			}
			if (++l > r) break;
		}	
		return res;
	}
};
```

##### 第2次：leetcode上

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        
        if (matrix.size() == NULL) {
			return {};
		}

        int m=matrix.size()-1, n=matrix[0].size()-1;
        
        int l=0, r=n, t=0, b=m;

        vector<int> res;
        while(l<=r && t<=b){
            for(int i=l;i<=r;i++){
                res.push_back(matrix[t][i]);
            }
            ++t;
            if(t>b) break;

            for(int i=t;i<=b;i++){
                res.push_back(matrix[i][r]);
            }
            --r;
            if(l>r) break;

            for(int i=r;i>=l;i--){
                res.push_back(matrix[b][i]);
            }
            --b;
            if(t>b) break;

            for(int i=b;i>=t;i--){
                res.push_back(matrix[i][l]);
            }
            ++l;
            if(l>r) break;

        }

        return res;
    }
};

```



##### 第2次：牛客上才行

```cpp
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        vector<int> ans;
        int t=0;
        int b =matrix.size()-1;
        int l=0;
        int r=matrix[0].size()-1;
        while(l<=r && t<=b){
            for (int i = l; i <= r; i++) ans.push_back(matrix[t][i] );// left to right.
            ++t;
            if(t>b) break;
            for (int i = t; i <= b; i++) ans.push_back(matrix[i][r]); // top to bottom.
            --r;
            if(l>r) break;
            for (int i = r; i >= l; i--) ans.push_back(matrix[b][i]); // right to left.
            b--;
            if(t>b) break;
            for (int i = b; i >= t; i--) ans.push_back(matrix[i][l]); // bottom to top.
            l++;
            if(l>r) break;
        }
        return ans;
    }
};
```



#### 61、扑克牌中的顺子

1、遍历五张牌(遇到大小王，跳过)，将5张牌加入set；
2、如果在set中出现重复，即返回false，不构成顺子；
3、并且在遍历过程中获得最大值与最小值；

```cpp
class Solution {
public:
	bool isStraight(vector<int>& nums) {
		set<int> s;
		//min和max是函数名
		//加_其实也表示私有成员变量，类的属性
		int _min = 14;
		int _max = 0;
		for (int i : nums) {
			if (i == 0) continue;
			_min = min(_min, i);
			_max = max(_max, i);
			if (s.count(i)) return false;
			s.insert(i);
		}
		return _max-_min < 5;
	}
};
```



#### 14- I. 剪绳子

题目分析：

- 先举几个例子，可以看出规律来。
- 4 ： 2*2
- 5 ： 2*3
- 6 ： 3*3
- 7 ： 2*2*3 或者4*3
- 8 ： 2*3*3
- 9 ： 3*3*3
- 10：2*2*3*3 或者4*3*3
- 11：2*3*3*3
- 12：3*3*3*3
- 13：2*2*3*3*3 或者4*3*3*3

下面是分析：

- 首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。
- 当然也可能有4，但是4=2*2，我们就简单些不考虑了。
- 5<2*3,6<3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。
- 其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2<3*3，那么题目就简单了。
- 直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。
- 由于题目规定m>1，所以2只能是1 1，3只能是2 1，这两个特殊情况直接返回就行了。
- 乘方运算的复杂度为：O(log n)，用动态规划来做会耗时比较多。

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if(n==2){
            return 1;
        }
        if(n==3){
            return 2;
        }
        int x=n % 3, y=n/3;
        if(x==0){
            return pow(3, y);
        }
        else if(x==1){
            return 2*2*pow(3, y-1); // 2*2>
        }
        else{
            return 2*pow(3, y);
        }

    }
};
```

#### 剑指 Offer 14- II. 剪绳子 II

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        if (n <= 3) return n - 1;
        
        long long result = 1;
        while (n > 4) {
            result = (result * 3) % 1000000007;
            n -= 3;
        }
        
        return (result * n) % 1000000007;
    }
};


```



#### 67、把字符串转换成整数

![1673001779136](/assets/1673001779136.png)

![1673001844625](/assets/1673001844625.png)

```cpp
class Solution {
public:
	int strToInt(string str) {
		int i = 0, flag = 1; //默认flag=1，正数
		int res = 0;
		//首部空格，删除之
		while (str[i] == ' ') ++i;
		//符号位，-1表示负数
		if (str[i] == '-') flag = -1;
		//符号位再+1
		if (str[i] == '-' || str[i] == '+') ++i;
		//如果是数字
		for (; i < str.size() && isdigit(str[i]); ++ i) {
			//判断是否越界
			if (res > INT_MAX / 10 || (res == INT_MAX / 10 && str[i] - '0' > 7))
				return flag == 1 ? INT_MAX : INT_MIN;
			// “此数字的 ASCII 码“与“0的ASCII 码”相减即可；
			//数字拼接
			res = res * 10 + (str[i] - '0');
		}
		return flag * res;
	}
};
```



### 位运算

#### JZ64 求1+2+3+…+n

从1连加到n，不能使用城乘除法，那就只能相加了。一个一个加，但是循环需要判断什么时候截止，我们又不能用关键词，这就难办了。

如果我们的和加上了n，则剩余的问题就是该数字加上1到n-1的和，这是一个子问题，因此可以用递归，从n回到1，再累加递归的结果。但是我们需要判断递归停止的条件，即到0时停止递归，不能用if、switch、？：等操作，我们可以采用与运算的短路操作： **在函数中，如果与运算成立，则继续，否则终止函数直接返回false。**

**具体做法：**

- step 1：用与运算判断n是否为正数，如果不是则结束递归。
- step 2：如果是累加子问题的和，并返回n。

```cpp
class Solution {
public:
    int Sum_Solution(int n) {
        n && (n+=Sum_Solution(n-1));
        return n;
    }
};
```



#### JZ56 数组中只出现一次的两个数字

所以，当只有一个出现了一次的数字的时候，则只需要将全部数进行异或运算，运算结果就剩下了那个只出现一次的数字了。

```cpp
public int[] singleNumber(int[] nums) {
    int x = 0;
    for(int num : nums)  // 1. 遍历 nums 执行异或运算
        x ^= num;
    return x;            // 2. 返回出现一次的数字 x
}
```

当二进制&1结果为1的时候，为奇数，反之为偶数。它们是按照最低位的不同来分组的。

**两个不同的数如何分组**：

需要找到两者中的那一位不同的二进制，然后得到分组的与值

那要怎么找到那一位不同的二进制呢？

> 我们看一个例子： 1，1，4，6
>
> 全部做异或运算结果为 4⊕6 = 0100⊕0110 = 0010
>
> 异或的运算规则是什么？ 相同的为0，不同的为1。所以我们根据两者异或出来的结果 0010，不就可以知道那一位不同了嘛？（为1的那一位就是不同的）

**答案**：

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型vector
     */
    vector<int> FindNumsAppearOnce(vector<int>& nums) {
        // write code here
        // 先将全部数进行异或运算，得出最终结果
        int x=0;
        for(auto num:nums){
            x^=num;
        }
        int num=x;

        // 找到那个可以充当分组去进行与运算的数
        // 从最低位开始找起
        int mask=1;
        while((num&mask)==0){
            mask<<=1;
        }

        // 进行分组，分成两组，转换为两组 求出现一次的数字 去求
        int a=0;
        int b=0;
        for(auto num:nums){
            if((num&mask)==0){
                a^=num;
            }
            else{
                b^=num;
            }
        }

        // 因为题目要求小的数放前面，所以这一做个判断
        if(a>b){
            int tmp=a;
            a=b;
            b=tmp;
        }

        return {a,b};

    }
};
```

#### JZ16 数值的整数次方

```cpp
class Solution {
public:
    double Pow(double x, int y ){
        cout<<x<<endl;
        double res=1;
        for(int i=0;i<y;i++){
            res*=x;
            cout<<res<<endl;
        }
        return res;
    }

    double Power(double base, int exponent) {
        if(exponent<0){
            base=1/base;
            cout<<base<<endl;
            exponent=-exponent;
        }
        return Pow(base, exponent);
    }
};
```



#### JZ15 二进制中1的个数

**具体做法：**

- step 1：遍历二进制的32位，通过移位0-31次实现。
- step 2：将移位后的1与数字进行位与运算，结果为1就记录一次。

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int整型 
     * @return int整型
     */
    int NumberOf1(int n) {
        // write code here
        int res=0;
        for(int i=0;i<32;i++){
            if((n&(1<<i))!=0){
                res++;
            }
        }
        return res;
    }
};
```

##### 第2次

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res=0;
        for(int i=0;i<32;i++){
            if((n&(1<<i))!=0){
                res++;
            }
        }
        return res;
    }
};
```



#### JZ65 不用加减乘除做加法

![1687008631467](/assets/1687008631467.png)

```cpp
class Solution {
public:
    int Add(int num1, int num2) {
        while(num2!=0){
            int sum =num1^num2;
            int tmp=(num1&num2)<<1;
            num1=sum;
            num2=tmp;
        }
        return num1;
    }
};
```



#### 15. 二进制中1的个数

![1688468951152](/assets/1688468951152.png)

![1688468982127](/assets/1688468982127.png)

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int res=0;
        while(n!=0){
            res+=(n&1);
            n>>=1;
        }
        return res;
    }
};
```



#### 65. 不用加减乘除做加法

![1691488233499](/assets/1691488233499.png)

```cpp
class Solution {
    public int add(int a, int b) {
        if(b==0) return a;
        return add(a^b,(a&b)<<1);
    }
}
```

```cpp
class Solution {
public:
    int add(int a, int b) {
        while (b != 0) {
            unsigned int carry = (unsigned int)(a & b) << 1;
            a = a ^ b;
            b = carry;
        }
        return a;
    }
};

```



### 排序

#### JZ3 数组中重复的数字

##### 方法1：利用set集合

**核心思想：**
        引入set集合，遍历数组元素，检查元素是否在集合中，不在则将元素插入到集合里面；否则表明当前元素在数组中重复，返回当前元素。

**复杂度分析：**
        代码使用了循环，循环次数为数组大小，因此该方法的时间复杂度为O(N)。由于引入额外的集合空间，因此空间复杂度为O(N)，最坏的情况是数组中的元素都不重复。

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param numbers int整型vector 
     * @return int整型
     */
    int duplicate(vector<int>& numbers) {
        // write code here
        set<int> s;
        for(auto number : numbers){
            if(s.count(number)>0){
                return number;
            }
            else{
                s.insert(number);
            }
        }
        return -1;
    }
};
```



#### 45. 把数组排成最小的数

##### 方法1：非常棒的排序方法

```cpp
class Solution {
public:
    string minNumber(vector<int>& nums) {
        vector<string> vec;
        for(int i=0;i<nums.size();i++){
            vec.push_back(to_string(nums[i]));
        }
        sort(vec.begin(), vec.end(), [](const string& a,const string& b){return a+b<b+a;});
        string res;
        for(int i=0;i<vec.size();i++){
            res+=vec[i];
        }
        return res;
    }
};
```



### 其他

#### 66、构建乘积数组

![Picture1.png](/assets/1624619180-vpyyqh-Picture1.png)

![1691487132135](/assets/1691487132135.png)



```cpp
class Solution {
public:
	vector<int> constructArr(vector<int>& a) {
		int len = a.size();
		if (len == 0) {
			return {};
		}
		//1 初始化数组ans,辅助变量total=1；
		vector<int> ans(len, 1);
		int tmp = 1;
		//2 计算 B[i] 的 下三角 各元素的乘积，直接乘入 B[i]；
		for (int i = 1; i < len; ++i) {
			ans[i] = ans[i-1] * a[i-1];
		}
		//3 计算 B[i] 的 上三角 各元素的乘积，记为 tmp，并乘入 B[i]；
		for (int i = len - 1; i > 0; --i) {
			tmp *= a[i];
			ans[i - 1] *= tmp;
		}
		return ans;
	}
};
```



#### 50、第一个只出现一次的字符

```cpp
class Solution {
public:
	char firstUniqChar(string s) {
		unordered_map<char, bool> m;
		int len = s.length();
		for (auto c : s) {
			//查找key是否存在，存在返回该键的元素的迭代器；不存返回map.end()
			//第一次不存在，找不到就是true
			//重复出现时，就会找到，=false
			m[c] = m.find(c) == m.end();
		}
		for (auto c : s) {
			//返回第一个为true的数
			if (m[c]) return c;
		}
		return ' ';
	}
};
```



#### 43. 1～n 整数中 1 出现的次数（超难）

分两种情况，例如：1234和2234，high为最高位，pow为最高位权重 在每种情况下都将数分段处理，即0-999，1000-1999，...，剩余部分

case1：最高位是1，则最高位的1的次数为last+1（1000-1234） 每阶段即0-999的1的个数1*countDigitOne(pow-1) 剩余部分1的个数为countDigitOne(last)--最高位已单独计算了

case2：最高位不是1，则最高位的1的次数为pow（1000-1999） 每阶段除去最高位即0-999，1000-1999中1的次数为high*countDigitOne(pow-1) 剩余部分1的个数为countDigitOne(last) 发现两种情况仅差别在最高位的1的个数，因此单独计算最高位的1（cnt），合并处理两种情况

```cpp
class Solution {
public:
    int countDigitOne(int n) {
        if(n<=0) return 0;
        if(n<10) return 1;
        // 取出最高位 以及 最高位的权重
        int high=n, pow=1;
        while(high>=10){
            high/=10;
            pow*=10;
        }
        // 除最高位的数字
        int last=n-high*pow;
        // high是否为1，最高位的1个数不同
        int cnt=high==1?last+1:pow;
        return cnt+high*countDigitOne(pow-1)+countDigitOne(last);
    }
};
```



#### 16. 数值的整数次方

##### 方法1：快速幂

![1688462285889](/assets/1688462285889.png)

![1688462306620](/assets/1688462306620.png)

![1688462323173](/assets/1688462323173.png)

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if(x==0) return 0;
        long b=n;
        double res=1.0;
        if(b<0){
            x=1/x;
            b=-b;
        }
        while(b>0){
            if((b&1)==1) res*=x; // 奇数
            x*=x;
            b>>=1;
        }
        return res;
    }
};
```



#### 17、打印从1到最大的n位数

面试不能这么写；

```cpp
class Solution {
public:
    vector<int> printNumbers(int n) {
        vector<int> res;
        string maxNum(n, '9');

        int m=stoi(maxNum);
        for(int i=1;i<=m;i++){
            res.emplace_back(i);
        }

        return res;
    }
};
```



##### 方法1：在字符串上模拟数字加法

```cpp
class Solution {
public:
    vector<int> printNumbers(int n) {
        if (n <= 0) return {};

        vector<int> result;
        string number(n, '0');

        while (!increment(number)) {
            result.push_back(stoi(number));
        }

        return result;
    }

   
private:
    bool increment(string& number) {
        int carry = 0;
        int len = number.length();

        for (int i = len - 1; i >= 0; --i) {
            int sum = number[i] - '0' + carry;

            if (i == len - 1) sum++;

            if (sum >= 10) {
                if (i == 0) {
                    return true;
                }
                else {
                    sum -= 10;
                    carry = 1;
                    number[i] = '0' + sum;
                }
            }
            else {
                number[i] = '0' + sum;
                break;
            }
        }

        return false;
    }
};

```



##### 方法2：数字排列，递归

```cpp
class Solution {
public:
    vector<int> printNumbers(int n) {
        if (n <= 0) return {};

        vector<int> result;
        string number(n, '0');

        dfs(number, result, n, 0);

        // 去除开头的0，并调整顺序
        result.erase(result.begin());

        return result;
    }

private:
    void dfs(string& number, vector<int>& result, int n, int index) {
        if (index == n) {
            result.push_back(stoi(number));
            return;
        }

        for (char digit = '0'; digit <= '9'; digit++) {
            number[index] = digit;
            dfs(number, result, n, index + 1);
        }
    }
};


```





