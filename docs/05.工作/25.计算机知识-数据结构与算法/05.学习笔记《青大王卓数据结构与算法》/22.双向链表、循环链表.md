---
title: 2-7-双向链表、循环链表
date: 2023-06-05 17:30:09
permalink: /pages/39f5ad/

---
数据结构——双向链表、循环链表
===============

> 循环链表

循环链表是头尾相接的链表(即表中最后一个结点的指针域指向头结点，整个链表形成一个**环**)(circular linked list)

  

![1685936324277](/assets/1685936324277.png)

**优点：**从表中任一结点出发均可访问全部结点

循环链表与单链表的主要**差异**当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同。在单链表中，判别条件为p!=NULL或p->next!=NULL,而循环单链表的判别条件为p!=L或p->next!=L。

![1685936333571](/assets/1685936333571.png)

![1685936341314](/assets/1685936341314.png)

![1685936349787](/assets/1685936349787.png)

![](/assets/1685936355723.png)

算法的复杂度O(1)（常数阶）

> 双向链表

![1685936364955](/assets/1685936364955.png)

为了克服单链表的这一缺点，老科学家们设计了双向链表(double linked list)是在单链表的每个结点中再设计一个指向其前驱结点的指针域。所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。这样链表中有两个不同方向的链。

![1685936371052](/assets/1685936371052.png)

![](https://i0.hdslb.com/bfs/article/d3dbb3ddb571440fae80da52b3bdfb09a1f689d6.png)

![1685936376104](/assets/1685936376104.png)

与单循环链表类似双向链表也可以有循环表(首尾相接形成"环"\[2个\])  
让头结点的前驱指针指向链表的最后一个结点  
最后一个结点的后继指针指向头结点

![1685936382462](/assets/1685936382462.png)

双向链表结构有**对称性**(设指针p指向某一个结点)  
**p->prior->next=p=p->next->prior**(前进一步后退一步相当于原地踏步)

![1685936387865](/assets/1685936387865.png)

在双向链表中有些操作(ListLength,GetElemment等因为只涉及一个方向的指针他们的算法与线性表的相同)但在插入和删除需要修改两个方向上的指针两者的算法复杂度均为O(n)  

> \[算法2.13\]双向链表的插入

带头结点的双向链表L中第i个位置之前(b)插入前插入一个新结点

![1685936395518](/assets/1685936395518.png)

![1685936400635](/assets/1685936400635.png)

单链表只需修改两个指针，而双向链表修改四个指针

算法复杂度O(n)  

![1685936405058](/assets/1685936405058.png)

![1685936409720](/assets/1685936409720.png)

算法复杂度O(n)

> 小结

![1685936415021](/assets/1685936415021.png)

> 链式存储结构的优点：

*   结点空间可以动态申请和释放；
    
*   数据元素的逻辑次序靠结点的指针来指示，插入和删除不需要移动元素。
    
*   链式存储结构的缺点：
    
*   存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占的字节数不多时，指针域所占的存储空间的比重显得很大。
    
*   存储密度是指结点**数据本身占用**的空间**/结点占用的空间总量**
    

![1685936423756](/assets/1685936423756.png)

链式存储结构是**非随机存取**结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。(对某个结点操作一般要先找到该结点)  

![1685936431270](/assets/1685936431270.png)

  
