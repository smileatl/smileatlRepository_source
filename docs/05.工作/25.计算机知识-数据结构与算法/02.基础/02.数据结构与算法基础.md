---
title: 数据结构与算法基础
date: 2023-06-05 10:55:29
permalink: /pages/9e1384/
categories: 
  - 工作
  - 计算机知识-数据结构与算法
  - 基础
tags: 
  - 
author: 
  name: smileatl
  link: https://github.com/smileatl
---
# 数据结构与算法基础

## 基础知识

### 数组

**数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**

创建数组中，不足的个数会用0补充



### 字符串

字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。

在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。

例如这段代码：

```cpp
char a[5] = "asd";
for (int i = 0; a[i] != '\0'; i++) {
}
```

在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。

例如这段代码:

```cpp
string a = "asd";
for (int i = 0; i < a.size(); i++) {
}
```

那么vector< char > 和 string 又有什么区别呢？

其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。

所以想处理字符串，我们还是会定义一个string类型。





### 其他

左闭右闭的是<=
左闭右开的是<



#### 容器底层实现

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn。

unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。



## 数据结构

### 链表

单链表：
常用操作 
指向头结点 p=L;
指向首元结点p=L->next;i=1; 
指向下一结点p=p->next;

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```



### 哈希表

记录的存储位置与关键字之间存在对应关系

数组的下标设为哈希表的键值（Key），而数组中的每一个数字设为哈希表的值（Value），这样每一个下标及数组中该下标对应的数字就组成了一个“键值-值”的配对。有了这样的哈希表，就可以在O(1)的时间内实现查找。

![1668129018303](/assets/1668129018303.png)

一般用unordered_set和unordered_map容器实现，有需要“键值-值”的映射就用map

**unordered_set容器**

- 等价为无序的set_容器
- 容器内的各个元素都互不相等

**unordered_map容器**

- 等价为无序的map容器
- map中所有的元素都是pair
- pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）

**有时候也可以简单用个数组**

- 使用数组来做哈希的题目，是因为题目都限制了数值的大小；如果没有限制数值的大小，就无法用数组来做哈希表了

**什么时候使用哈希法**，当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。



### 栈和队列

匹配问题都是栈的强项，**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。



### 二叉树

#### 种类

##### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。深度为k，有2^k-1个节点。

![1685931873698](/assets/1685931873698.png)

##### 完全二叉树

在完全二叉树中 层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

![img](/assets/20200920221638903.png)

##### 二叉搜索树

**二叉搜索树是一个有序树**

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

![img](/assets/20200806190304693-1677555641980.png)

##### 平衡二叉树

一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1.

##### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。（最后一棵左右两个子树的高度差的绝对值超过了1）

![img](/assets/20200806190511967.png)



#### 存储方式

##### 链式存储

用指针

![img](/assets/2020092019554618.png)

##### 顺序存储

用数组，**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

![img](/assets/20200920200429452.png)

遍历方式

- 深度优先遍历，用递归比较方便；迭代法可以借助栈来实现
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历，一般使用队列来实现
  - 层次遍历（迭代法）

#### 代码定义

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;  // 左右指针指向左右孩子
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}  // 构造函数
};
```

#### 深度与高度

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）

## 算法

### 最易懂的贪心算法

贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的



### 双指针

- 双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。
- 若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。
- 若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。



### 二分查找

![1668136245558](/assets/1668136245558.png)

**前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

#### 二分法第一种写法

第一种写法，我们定义 target 是在一个在==左闭右闭==的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while ==(left <= right)== 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

![704.二分查找](/assets/20210311153055723.jpg)

#### 二分法第二种写法

如果说定义 target 是在一个在==左闭右开==的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while ==(left < right)==，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（**注意和方法一的区别**）

![704.二分查找1](/assets/20210311153123632.jpg)





### 排序算法

#### 快速排序（左闭右开）

```cpp
//左闭右开
void quick_sort(vector<int>& nums, int l, int r) {
	//如果数组大小为1，则无需排序
	if (l + 1 >= r) {
		return;
	}
	//因为传入的是nums.size()所以要减1
	int first = l, last = r - 1, key = nums[first];
	//确定中心点位置为first
	while (first < last) {
		while (first < last && nums[last] >= key) {
			--last;
		}
		//从后往前，找到比key值小的数，搬到first的位置
		nums[first] = nums[last];
		while (first < last && nums[first] <= key) {
			++first;
		}
		//从前往后，找到比key值大的数，搬到刚才空出来的last的位置
		nums[last] = nums[first];
	}
	//把key值赋给first位，此时的first=last
	nums[first] = key;
	//对低子表递归排序
	quick_sort(nums, l, first);
	//对高子表递归排序
	quick_sort(nums, first + 1, r);
	
}
```

#### 归并排序

```cpp
//归并排序
void merge_sort(vector<int>& nums, int l, int r, vector<int>& temp) {
	if (l + 1 >= r) {
		return;
	}
	// divide
	int m = l + (r - l) / 2;
	merge_sort(nums, l, m, temp);
	merge_sort(nums, m, r, temp);
	// conquer
	int p = l, q = m, i = l;
	
	//将两个有序序列合并成一个有序序列
	while (p < m || q < r) {
		if (q >= r || (p < m && nums[p] <= nums[q])) {
			temp[i++] = nums[p++];
		}
		else {
			temp[i++] = nums[q++];
		}
	}
	for (i = l; i < r; ++i) {
		nums[i] = temp[i];
	}
}
```



### 递归

#### 明确递归三要素

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

#### 前序遍历

```cpp
class Solution {
public:
    // 1、确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入vector来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void
    void traversal(TreeNode* cur, vector<int>& vec) {
        // 2、确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return
        if (cur == NULL) return;
        // 3、确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};
```

#### 中序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}
```

#### 后序遍历

```cpp
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```



### 迭代法

#### 前序遍历

```cpp
// 代码中空节点不入栈
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
};
```

#### 中序遍历

迭代过程中，有两个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```

#### 后序遍历

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

![前序到后序](/assets/20200808200338924.png)

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }
};
```



### 回溯

回溯是递归的副产品，只要递归就会有回溯

**效率：**不高效，本质是穷举，穷举所有可能，然后选出我们想要的答案

#### 可解决问题

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**组合是不强调元素顺序的，排列是强调元素顺序**。例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

如果是一个集合来求组合的话，就需要startIndex，例如：[77.组合 (opens new window)](https://programmercarl.com/0077.组合.html)，[216.组合总和III (opens new window)](https://programmercarl.com/0216.组合总和III.html)。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：[17.电话号码的字母组](https://programmercarl.com/0017.电话号码的字母组合.html)

#### 理解回溯法

**回溯法解决的问题都可以抽象为树形结构**。

回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

#### 模板

##### 回溯函数模板返回值以及参数

返回值一般为void

```cpp
void backtracking(参数)
```

##### 回溯函数终止条件

什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

```cpp
if (终止条件) {
    存放结果;
    return;
}
```

##### 回溯搜索的遍历过程

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

![回溯算法理论基础](/assets/20210130173631174.png)

```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

- for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。
- backtracking这里自己调用自己，实现递归。
- 可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

#### 回溯算法模板框架

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果   // 处理过程和回溯过程是一一对应的
    }
}
```



清楚子集问题和组合问题、分割问题的的区别，**子集是收集树形结构中树的所有节点的结果**。

**而组合问题、分割问题是收集树形结构中叶子节点的结果**。





### 搜索

#### 深度优先搜索

前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。
只是对结点访问的顺序有一点不同，其它完全相同。

#### 回溯法



##### 回溯算法与深度优先遍历

采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。

**深度优先搜索** 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 **尽可能深** 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 **回溯** 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

##### 与动态规划的区别

##### 共同点

用于求解多阶段决策问题。多阶段决策问题即：

- 求解一个问题分为很多步骤（阶段）；
- 每一个步骤（阶段）可以有多种选择。

##### 不同点

- 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
- 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。

![1668652180608](/assets/1668652180608.png)



### 动态规划

​		这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多==重叠子问题==的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间 · · · · · ·动态规划只能应用于有==最优子结构==的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”

​		通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，==动态规划保存子问题的解，避免重复计算。==解决动态规划问题的关键是找到==状态转移方程====，这样我们可以通过计算和储存子问题的解来求解最终问题。==

​		同时，我们也可以对动态规划进行空间压缩，起到节省空间消耗的效果。

​		在一些情况下，动态规划可以看成是带有==状态记录==（memoization）的优先搜索。状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。==动态规划是自下而上的，即先解决子问题，再解决父问题==；而==用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算==。==如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。==

#### 代码随想录

动规是由前一个状态推导出来的，而贪心是局部直接选最优的

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组





### 分治法

​		顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为1的子数组；“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为1的子数组开始，最终合成一个大数组。
​		我们也使用数学表达式来表示这个过程。定义 T(n)表示处理一个长度为 n 的数组的时间复杂度，则归并排序的时间复杂度递推公式为 T(n) = 2T(n/2) + O(n)。其中 2T(n/2) 表示我们分成了两个长度减半的子问题，O⚜n⚝ 则为合并两个长度为 n/2 数组的时间复杂度。
​		通过递推公式得到最终的时间复杂度。利用著名的主定理（Master theorem）求解：
![1670498074979](/assets/1670498074979.png)

​		通过主定理我们可以知道，归并排序属于第二种情况，且时间复杂度为 O(n)log(n).其他的分治问题也可以通过主定理求得时间复杂度。
​		另外，==自上而下的分治可以和memoization结合==，避免重复遍历相同的子问题。==如果方便推导，也可以换用自下而上的动态规划方法求解==。

### KMP



应用在字符串匹配上

**主要思想：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

#### 前缀表

next数组就是一个前缀表（prefix table）。

![KMP详解1](/assets/KMP精讲1.gif)

**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**
前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。

**前缀表：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

#### 最长公共前后缀

文章中字符串的

- 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。
- 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。

**正确理解什么是前缀什么是后缀很重要**!

**因为前缀表要求的就是相同前后缀的长度。**

而最长公共前后缀里面的“公共”，更像是说前缀和后缀公共的长度。这其实并不是前缀表所需要的。

所以字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。

#### 为什么一定要用前缀表

![1677417539118](/assets/1677417539118.png)

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，==匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了==。**

#### 如何计算前缀表

长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：

![1677418482634](/assets/1677418482634.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

![1677419355910](/assets/1677419355910.png)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

#### 前缀表与next数组

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

其实**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

根据next数组来 匹配文本串s，和模式串t了。注意next数组是新前缀表（旧前缀表统一减一了）。

![KMP精讲4](/assets/KMP精讲4.gif)

#### 时间复杂度分析

其中n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

暴力的解法显而易见是O(n × m)，所以**KMP在字符串匹配中极大地提高了搜索的效率。**

#### 构造next数组

```cpp
1 初始化
2 处理前后缀不相同的情况
3 处理前后缀相同的情况

// 函数参数为指向next数组的指针，和一个字符串
// 构造next数组其实就是计算模式串s，前缀表的过程
void getNext(int* next, const string& s)
{
    // 定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。
	// 然后还要对next数组进行初始化赋值，如下：
    // 前后先都为-1
    int j = -1;
   	next[0] = j;
    
    // 因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。
    // 所以遍历模式串s的循环下标i 要从 1开始，代码如下：
    for (int i = 1; i < s.size(); i++) {
        // 如果 s[i] 与 s[j+1]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。
        // next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。
		// 那么 s[i] 与 s[j+1] 不相同，就要找 j+1前一个元素在next数组里的值（就是next[j]）。
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
    		j  = next[j]; // 向前回退
		}
        
        // 如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
    		j++;
		}
		next[i] = j;
    }   
}
```

![KMP精讲3](/assets/KMP精讲3.gif)

##### 使用next数组来做匹配

```cpp
// j 指向模式串起始位置，i指向文本串起始位置。
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
    // 如果 s[i] 与 t[j + 1] 不相同，j就要从next数组里寻找下一个匹配的位置。
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
        j = next[j]; // j 寻找之前匹配的位置
    }
    
    // 如果 s[i] 与 t[j + 1] 相同，那么i 和 j 同时向后移动， 代码如下：
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    
    // 本题要在文本串字符串中找出模式串出现的第一个位置 (从0开始)，所以返回当前在文本串匹配模式串的位置i 减去 模式串的长度，就是文本串字符串中出现模式串的第一个位置。
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
//如何判断在文本串s里出现了模式串t呢，如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了。
```

















