---
title: 5-9-哈夫曼编码
date: 2023-06-05 17:30:09
permalink: /pages/b8c7a8/
categories:
  - note_book
  - 《青大王卓数据结构与算法》学习笔记
tags:
  - 
author: 
  name: smileatl
  link: https://github.com/smileatl
---
数据结构——哈夫曼编码
===========

> 哈夫曼编码
> =====

![1685953591643](/assets/1685953591643.png)

![1685953598694](/assets/1685953598694.png)

![1685953603993](/assets/1685953603993.png)

![1685953608705](/assets/1685953608705.png)

![1685953617662](/assets/1685953617662.png)

T;ACS都是叶子结点，根到一个字符不会路过另一个字符

![1685953622532](/assets/1685953622532.png)

第一步：构造哈夫曼树不清楚的看之前的文章  

![1685953636645](/assets/1685953636645.png)

![1685953629047](/assets/1685953629047.png)

第二步：左分支标注0右分支标注1某个字符的哈夫曼编码为从根结点到字符对应的叶子结点路过分支的标注形成的由0和1构成的序列 而自上而下标注用算法不太好实现所以改从叶子结点到根结点自下而上对分支进行标注

具体过程(求G的编码)  

G是7号结点，他的parent是8 找到8号，判断G是8号的左孩子还是右孩子(8号的哪个域是7)-->8号的lch为7-->G是8号的左孩子-->标记0....直到根结点(parent=0)哈夫曼编码从根结点到叶子结点而现在是叶子到根哈夫曼编码需要把得到的值倒过来(很容易想到后进先出的栈)

但实际我们是求哈夫曼树的7个叶子结点的编码(A-G)

for（i=1;i<=n;i++）{

//求当前字符的编码

反复找双亲 判断是左孩子还是右孩子 标注 ...... 直到parent=0 循环次数不确定while(f!=0)

f表示当前结点的parent值

}

用字符串数组(二维数组)来存储字符的编码 字符串通过char\[\]实现

![1685953641713](/assets/1685953641713.png)

得到的值与编码相反的定义一个cd\[\](数组)保存得到的值

数组的长度设哈夫曼树有n个结点分支（层次）数最多为n-1 而字符串要多一个\\0作为结束的标志 长度n，0~n-2存放得到的值，第一个得到的值放在cd\[n-2\](最后)

这里是A-G n=7

![1685953646595](/assets/1685953646595.png)

当i=1(求A的编码) A的parent=13 13的lch=1(左孩子)标注0-->存到cd\[5\]-->start--（start=4）13号parent=0循环结束-->字符串复制函数复制到HC\[1\]

i=2(求B的编码)B的parent=12 12的rch=2(右孩子)标注1-->存到cd\[5\]-->start--；start=4 -->12的parent=13 13的rch=12(右孩子)标注1 存入cd\[start\]-->13号parent=0循环结束-->哈夫曼编码cd\[start\]--\\0 字符串复制函数复制到HC\[2\]

.....

7个字符的编码都得到

![1685953651357](/assets/1685953651357.png)

![1685953656872](/assets/1685953656872.png)

![1685953667521](/assets/1685953667521.png)

![1685953672371](/assets/1685953672371.png)

![1685953676800](/assets/1685953676800.png)

![1685953745617](/assets/1685953745617.png)

![1685953751314](/assets/1685953751314.png)

算法的实现不做具体的介绍

明文-->哈夫曼编码(编码反过来叫解码)

  
